<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Календарь для Telegram</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        // Импортируем необходимые модули Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Оборачиваем весь код в IIFE для создания замкнутой области видимости
        (function() {
            'use strict';

            // Получаем ссылки на статические элементы DOM сразу
            const loadingIndicatorElement = document.getElementById('loadingIndicator');
            const editModalOverlayElement = document.getElementById('editModalOverlay');
            const editModalTitleElement = document.getElementById('editModalTitle');
            const editModalBodyElement = document.getElementById('editModalBody');
            const viewModalOverlayElement = document.getElementById('viewModalOverlay');
            const viewModalTitleElement = document.getElementById('viewModalTitle');
            const viewModalBodyElement = document.getElementById('viewModalBody');
            const confirmModalOverlayElement = document.getElementById('confirmModalOverlay');
            const confirmModalMessageElement = document.getElementById('confirmModalMessage');
            const confirmModalConfirmBtnElement = document.getElementById('confirmModalConfirmBtn');
            const confirmModalCancelBtnElement = document.getElementById('confirmModalCancelBtn');
            const summaryModalOverlayElement = document.getElementById('summaryModalOverlay');
            const summaryModalTitleElement = document.getElementById('summaryModalTitle');
            const summaryModalBodyElement = document.getElementById('summaryModalBody');

            /**
             * CONFIG: Константы и конфигурация приложения
             */
            const CONFIG = {
                // Default Telegram ID for the admin (user's ID)
                DEFAULT_ADMIN_ID: "670669284", // Должен совпадать с TELEGRAM_ADMIN_CHAT_ID
                DEFAULT_ADMIN_NAME: "Y", // Имя администратора
                ROLE_NAMES: {
                    'admin': 'Администратор',
                    'boss': 'Начальник',
                    'worker': 'Работяга',
                    'guest': 'Гость'
                },
                DOM_SELECTORS: {
                    container: '#appContainer',
                    monthSelector: '#monthSelector', // This is now handled by custom dropdowns, but selector still exists
                    newOfficerName: '#newOfficerName',
                    newOfficerTelegramId: '#newOfficerTelegramId',
                    dutyCalendarGrid: '#dutyCalendarGrid',
                    technicianCalendarGrid: '#technicianCalendarGrid',
                    generalCalendarGrid: '#generalCalendarGrid',
                    statsList: '#statsList',
                    currentOfficersList: '#currentOfficersList',
                    actionButtons: '#actionButtons',
                    tabNavigation: '#tabNavigation',
                    // Removed loadingIndicator, editModal, viewModal, confirmModal, summaryModal from DOM_SELECTORS
                    // as their elements are now directly referenced
                    firebaseSettings: {
                        section: '#firebaseSettingsSection',
                    }
                },
                STORAGE_KEYS: {
                    USERS_COLLECTION: 'users',
                    MONTHS_COLLECTION: 'months',
                },
                SHIFT_TYPES: ["8", "ДС", "День караул", "Ночь караул", "Отсыпной", "Выходной", "Отпуск", "Больничный"],
                NO_DUTY_LABEL: "Нет дежурства",
                NAME_REGEX: /^[А-ЯЁа-яёA-Za-z\- ]{2,}(\s[А-ЯЁA-Za-z]\.[А-ЯЁA-Za-z]\.)?$/,
                INITIAL_DATA: {
                    officers: ["Морозов В.А.", "Ребраков Т.В.", "Костырин С.С.", "Бонадыков В.В.", "Бурлаков М.Ю.", "Артемьев А.М.", "Мефед И.С."],
                    technicians: ["Ребраков Т.В.", "Морозов В.А.", "Кузавлев П.С.", "Лебедев А.В.", "Денщиков А.А."],
                    julyDuties: { "1": "Ребраков Т.В.", "2": "Костырин С.С.", "3": "Морозов В.А.", "4": "Ребраков Т.В.", "6": "Костырин С.С.", "7": "Костырин С.С.", "8": "Ребраков Т.В.", "9": "Морозов В.А.", "10": "Морозов В.А.", "11": "Костырин С.С.", "12": "Ребраков Т.В.", "13": "Морозов В.А.", "14": "Костырин С.С.", "15": "Ребраков Т.В.", "16": "Морозов В.А.", "17": "Ребраков Т.В.", "18": "Ребраков Т.В.", "19": "Костырин С.С.", "20": "Морозов В.А.", "21": "Костырин С.С.", "22": "Ребраков Т.В.", "23": "Морозов В.А.", "24": "Костырин С.С.", "25": "Ребраков Т.В.", "26": "Морозов В.А.", "27": "Костырин С.С.", "28": "Костырин С.С.", "29": "Морозов В.А.", "30": "Костырин С.С.", "31": "Ребраков Т.В." },
                    technicianDuties: {
                        "1": [{person: "Кузавлев П.С.", shift: "8"}],
                        "2": [{person: "Лебедев А.В.", shift: "8"}],
                        "3": [{person: "Денщиков А.А.", shift: "8"}],
                    },
                    generalScheduleData: {
                        "1": [{ person: "Ребраков Т.В.", shift: "8" }, { person: "Кузавлев П.С.", shift: "ДС" }],
                    }
                },
                // Hardcoded Firebase configuration for local testing
                FIREBASE_CONFIG: {
                    apiKey: "AIzaSyBrfimxAJC-fN4aThvXH_B4jMWDA4pwysk",
                    authDomain: "ik2grafik.firebaseapp.com",
                    projectId: "ik2grafik",
                    storageBucket: "ik2grafik.firebasestorage.app",
                    messagingSenderId: "141207090372",
                    appId: "1:141207090372:web:b292ee339a23640027c591",
                    measurementId: "G-CSVDH3P8V1"
                },
                // --- НАСТРОЙКИ TELEGRAM БОТА ДЛЯ УВЕДОМЛЕНИЙ ---
                // TELEGRAM_BOT_TOKEN и TELEGRAM_ADMIN_CHAT_ID теперь не хранятся здесь напрямую
                // Они должны быть доступны через ваш Cloudflare Worker (telegram-auth-proxy.ik2grafik.workers.dev)
                // --- КОНЕЦ НАСТРОЕК TELEGRAM БОТА ---
            };

            /**
             * STATE: Единственный источник правды для состояния приложения.
             */
            const STATE = {
                // Используем __app_id, предоставленный средой Canvas, или 'default-app-id' для локального тестирования
                appId: typeof __app_id !== 'undefined' ? __app_id : 'default-app-id',
                db: null,
                auth: null,
                telegramUser: null,
                currentUserId: null,
                userRole: 'guest',
                year: new Date().getFullYear(),
                currentMonth: new Date().getMonth(),
                activeTab: 'duty',
                isEditMode: false,
                hasUnsavedChanges: false,
                duties: {},
                techDuties: {},
                generalSchedule: {},
                users: {},
                officers: [],
                technicians: [],
                colors: {},
                confirmModalResolve: null,
                currentSelectedDay: null,
                unsubscribeListeners: [],
            };

            /**
             * SERVICE: "Мозг" приложения. Управляет состоянием и бизнес-логикой.
             */
            const SERVICE = {
                async init() {
                    VIEW.showLoadingIndicator();
                    try {
                        this.initTelegram(); // Инициализация Telegram WebApp и получение initDataUnsafe

                        // Откладываем проверку подписи Telegram, чтобы initData успел заполниться
                        await new Promise(resolve => {
                            setTimeout(async () => {
                                const isTelegramAuthValid = await this.validateTelegramAuthSignature();
                                if (!isTelegramAuthValid) {
                                     console.warn("Telegram initData был недоступен или проверка подписи не удалась после задержки.");
                                     // Если проверка подписи не прошла, рендерим ошибку авторизации Telegram
                                     VIEW.renderUnauthorized('telegram_auth_failed');
                                     VIEW.hideLoadingIndicator();
                                     return; // Прерываем инициализацию, если Telegram авторизация не прошла
                                }
                                resolve(); // Разрешаем промис, чтобы продолжить инициализацию
                            }, 500); // Задержка 500 мс
                        });

                        await this.initFirebase();
                        if (!STATE.auth) {
                            console.error("Firebase Auth is not initialized. Exiting init.");
                            VIEW.showNotification("Ошибка: Служба аутентификации Firebase недоступна. Проверьте конфигурацию.", "error");
                            VIEW.renderUnauthorized('auth_failed');
                            VIEW.hideLoadingIndicator(); // Hide on error path
                            return;
                        }
                        await this.authenticateFirebase();
                        if (!STATE.currentUserId) {
                            console.error("Authentication failed, currentUserId is null. Exiting init.");
                            VIEW.renderUnauthorized('auth_failed');
                            VIEW.hideLoadingIndicator(); // Hide on error path
                            return;
                        }
                        await this.loadUsersFromFirestore(); // Эта функция теперь будет адаптирована
                        this.determineUserRole();
                        // Проверка роли пользователя. Если гость, показываем сообщение об ограничении доступа.
                        if (STATE.userRole === 'guest') {
                            console.error("User role determined as 'guest'. Rendering unauthorized.");
                            VIEW.renderUnauthorized('guest_role');
                            VIEW.hideLoadingIndicator(); // Hide on error path
                            return;
                        }
                        
                        // Render the app shell first
                        VIEW.renderAppShell();

                        // Use setTimeout to ensure DOM elements are fully available after innerHTML
                        setTimeout(() => {
                            try {
                                // Initialize elements that are now in the DOM
                                VIEW.initAppElements();
                                
                                // Continue with the rest of the initialization
                                this.setupFirestoreListeners();
                                CONTROLLER.init();
                                VIEW.renderAll();
                                VIEW.renderMonthSelector();
                            } catch (innerError) {
                                console.error("Error during post-shell rendering initialization:", innerError);
                                VIEW.showNotification("Произошла ошибка при отрисовке интерфейса. Подробности в консоли.", "error");
                                VIEW.renderUnauthorized('unhandled_error');
                            } finally {
                                VIEW.hideLoadingIndicator(); // Hide only after everything is rendered
                            }
                        }, 0); // Small delay to allow DOM to settle
                    } catch (e) {
                        console.error("Unhandled error during application initialization:", e);
                        VIEW.showNotification("Произошла неожиданная ошибка при инициализации приложения. Подробности в консоли.", "error");
                        VIEW.renderUnauthorized('unhandled_error');
                        VIEW.hideLoadingIndicator(); // Hide on unhandled error path
                    }
                },

                async initFirebase() {
                    try {
                        let firebaseConfig = CONFIG.FIREBASE_CONFIG; // По умолчанию используем жестко закодированную конфигурацию

                        // Если __firebase_config определена (т.е. мы в среде Canvas), пытаемся ее использовать
                        if (typeof __firebase_config !== 'undefined' && __firebase_config) {
                            try {
                                const parsedConfig = JSON.parse(__firebase_config);
                                // Используем распарсенную конфигурацию, только если она является действительным объектом с ключами
                                if (parsedConfig && Object.keys(parsedConfig).length > 0) {
                                    firebaseConfig = parsedConfig;
                                } else {
                                    console.warn("Parsed __firebase_config is empty or invalid, falling back to hardcoded config.");
                                    VIEW.showNotification("Предупреждение: Конфигурация Firebase из Canvas пуста или недействительна. Используется жестко закодированная конфигурация.", "warning");
                                }
                            } catch (e) {
                                console.warn("Could not parse __firebase_config, falling back to hardcoded config:", e);
                                VIEW.showNotification("Предупреждение: Не удалось разобрать конфигурацию Firebase из Canvas. Используется жестко закодированная конфигурация.", "warning");
                            }
                        }

                        if (!firebaseConfig || Object.keys(firebaseConfig).length === 0 || !firebaseConfig.apiKey || !firebaseConfig.projectId) {
                            console.error("Firebase config is missing or invalid. Config:", firebaseConfig);
                            VIEW.showNotification("Ошибка: Неверная конфигурация Firebase. Убедитесь, что Firebase настроен правильно.", "error");
                            STATE.db = null;
                            STATE.auth = null;
                            return;
                        }
                        const app = initializeApp(firebaseConfig);
                        STATE.db = getFirestore(app);
                        STATE.auth = getAuth(app);
                    } catch (e) {
                        console.error("Error initializing Firebase:", e);
                        VIEW.showNotification("Ошибка инициализации Firebase. Попробуйте позже.", "error");
                        STATE.db = null;
                        STATE.auth = null;
                    }
                },

                async authenticateFirebase() {
                    if (!STATE.auth) {
                        console.error("Firebase Auth is not initialized. Cannot authenticate.");
                        VIEW.showNotification("Ошибка: Служба аутентификации Firebase недоступна. Проверьте конфигурацию.", "error");
                        STATE.currentUserId = null;
                        return;
                    }
                    try {
                        console.log("Attempting Firebase authentication...");
                        // Используем __initial_auth_token, если доступен (для Canvas), иначе анонимный вход
                        if (typeof __initial_auth_token !== 'undefined') {
                            const userCredential = await signInWithCustomToken(STATE.auth, __initial_auth_token);
                            STATE.currentUserId = userCredential.user.uid;
                        } else {
                            const userCredential = await signInAnonymously(STATE.auth);
                            STATE.currentUserId = userCredential.user.uid;
                        }
                    } catch (error) {
                        console.error("Error during Firebase authentication:", error);
                        VIEW.showNotification("Ошибка аутентификации. Убедитесь, что Firebase Authentication включен для вашего проекта 'ik2grafik' в консоли Firebase (метод 'Anonymous').", "error");
                        STATE.currentUserId = null;
                    }
                },

                initTelegram() {
                    const tg = window.Telegram.WebApp;
                    tg.ready();
                    STATE.telegramUser = tg.initDataUnsafe.user; // Используем initDataUnsafe для начального отображения
                    if (!STATE.telegramUser) {
                        console.warn("Telegram WebApp user data not available, using fallback admin ID for testing.");
                        STATE.telegramUser = { id: parseInt(CONFIG.DEFAULT_ADMIN_ID), first_name: 'Тестовый', username: 'test_admin_user' };
                    }
                    tg.expand();
                },

                // Функция для проверки подписи Telegram
                async validateTelegramAuthSignature() {
                    try {
                        const initData = window.Telegram.WebApp.initData;
                        console.log("DEBUG: Telegram.WebApp.initData получен:", initData); // Более явный лог

                        if (!initData || initData.trim() === '') {
                            console.error("Ошибка: Telegram.WebApp.initData пуст или отсутствует. Невозможно проверить подпись.");
                            VIEW.showNotification("Ошибка авторизации Telegram: initData отсутствует. Убедитесь, что приложение запущено из Telegram.", "error");
                            return false; // Возвращаем false, так как initData отсутствует
                        }

                        console.log("Отправка initData для проверки на прокси:", initData);

                        // Парсим initData, чтобы извлечь hash
                        const params = new URLSearchParams(initData);
                        const hash = params.get('hash');
                        const queryId = params.get('query_id');
                        const user = params.get('user');
                        const authDate = params.get('auth_date');

                        const res = await fetch("https://telegram-auth-proxy.ik2grafik.workers.dev", { // Используем ваш debug URL
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                queryId: queryId,
                                initData: user, // Это initData.user из оригинального запроса
                                signature: hash, // <--- ИСПРАВЛЕНО: Отправляем hash
                                authDate: authDate,
                                // botToken: TELEGRAM_TOKEN // Бот-токен не отправляется с клиента
                            })
                        });

                        const data = await res.json();
                        console.log("Ответ отладочного прокси Telegram:", data); // Логируем весь ответ

                        if (!data.ok) {
                            VIEW.showNotification(`Ошибка проверки подписи Telegram: ${data.error || 'Неизвестно'}`, "error");
                            return false;
                        }
                        return true; // Подпись успешно проверена

                    } catch (err) {
                        console.error("Ошибка при вызове прокси Telegram для проверки подписи:", err);
                        VIEW.showNotification("Ошибка при вызове прокси Telegram для проверки подписи. Произошла сетевая ошибка.", "error");
                        return false; // Если произошла ошибка fetch, считаем авторизацию неуспешной
                    }
                },

                async loadUsersFromFirestore() {
                    if (!STATE.db) {
                        VIEW.showNotification("Ошибка: База данных не инициализирована. Невозможно загрузить пользователей.", "error");
                        return;
                    }
                    const usersRef = collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.USERS_COLLECTION}`);
                    try {
                        STATE.users = {};
                        const currentTelegramId = STATE.telegramUser.id.toString();
                        const telegramUserName = SERVICE.sanitizeInput(`${STATE.telegramUser.first_name} ${STATE.telegramUser.last_name || ''}`).trim();

                        // Шаг 1: Загружаем документ текущего пользователя
                        const currentUserDocRef = doc(usersRef, currentTelegramId);
                        const currentUserDocSnap = await getDoc(currentUserDocRef);
                        
                        let currentUserData = null;
                        if (currentUserDocSnap.exists()) {
                            currentUserData = currentUserDocSnap.data();
                            STATE.users[currentUserDocSnap.id] = currentUserData;
                        }

                        // Шаг 2: Обеспечиваем существование и корректную роль для DEFAULT_ADMIN_ID
                        const defaultAdminDocRef = doc(usersRef, CONFIG.DEFAULT_ADMIN_ID);
                        const defaultAdminDocSnap = await getDoc(defaultAdminDocRef);

                        if (!defaultAdminDocSnap.exists()) {
                            // Создаем default admin, если его нет
                            await setDoc(defaultAdminDocRef, {
                                name: CONFIG.DEFAULT_ADMIN_NAME,
                                role: 'admin',
                                active: true
                            });
                            STATE.users[CONFIG.DEFAULT_ADMIN_ID] = { name: CONFIG.DEFAULT_ADMIN_NAME, role: 'admin', active: true };
                        } else if (defaultAdminDocSnap.data().role !== 'admin') {
                            // Обновляем роль default admin, если она некорректна
                            await updateDoc(defaultAdminDocRef, { role: 'admin' });
                            STATE.users[CONFIG.DEFAULT_ADMIN_ID] = { ...defaultAdminDocSnap.data(), role: 'admin' };
                        } else {
                            STATE.users[CONFIG.DEFAULT_ADMIN_ID] = defaultAdminDocSnap.data();
                        }

                        // Шаг 3: Определяем роль текущего пользователя после потенциального создания/обновления админа
                        // Это важно, так как текущий пользователь может быть DEFAULT_ADMIN_ID
                        this.determineUserRole(); 

                        // Шаг 4: Если текущий пользователь является администратором, загружаем всех пользователей
                        if (STATE.userRole === 'admin') {
                            const querySnapshot = await getDocs(usersRef);
                            querySnapshot.forEach(doc => {
                                if (doc.data().name && doc.data().role) {
                                    STATE.users[doc.id] = doc.data();
                                } else {
                                    console.warn(`Пропущен некорректный документ пользователя: ${doc.id}`, doc.data());
                                }
                            });
                        } else {
                            // Если текущий пользователь не админ и его документа не было, создаем его как гостя
                            if (!currentUserDocSnap.exists()) {
                                STATE.users[currentTelegramId] = {
                                    name: telegramUserName || `Пользователь ${currentTelegramId}`,
                                    role: 'guest',
                                    active: true
                                };
                                await setDoc(currentUserDocRef, STATE.users[currentTelegramId]);
                                SERVICE.sendAdminNotification(
                                    `Новый пользователь зарегистрировался: <b>${telegramUserName}</b> (ID: <code>${currentTelegramId}</code>). ` +
                                    `Роль: Гость. Пожалуйста, измените его роль в разделе "Управление персоналом" в приложении.`
                                );
                            } else if (currentUserData && currentUserData.name !== telegramUserName) {
                                // Обновляем имя пользователя, если оно изменилось
                                await updateDoc(currentUserDocRef, { name: telegramUserName });
                                STATE.users[currentTelegramId].name = telegramUserName;
                            }
                        }

                        // Обновляем списки офицеров и техников на основе актуальных данных пользователей
                        this.determineUserRole(); 

                        const allInitialPeople = [...new Set([...CONFIG.INITIAL_DATA.officers, ...CONFIG.INITIAL_DATA.technicians])];
                        for (const name of allInitialPeople) {
                            const existingUser = Object.values(STATE.users).find(u => u.name === name);
                            if (!existingUser) {
                                console.warn(`Пользователь '${name}' из начального списка не найден в Firestore и не добавлен, так как нет Telegram ID.`);
                            }
                        }
                    } catch (e) {
                        console.error("Error in loadUsersFromFirestore:", e);
                        VIEW.showNotification("Ошибка загрузки данных пользователей. Проверьте правила безопасности Firestore.", "error");
                        throw e;
                    }
                },

                // --- НОВАЯ ФУНКЦИЯ ДЛЯ ОТПРАВКИ УВЕДОМЛЕНИЙ АДМИНИСТРАТОРУ ---
                async sendAdminNotification(message) {
                    // URL вашего Cloudflare Worker для отправки уведомлений
                    const workerUrl = "https://telegram-auth-proxy.ik2grafik.workers.dev"; // Используем ваш debug URL для Worker

                    const payload = {
                        action: "sendMessage", // Добавляем действие, чтобы Worker знал, что делать
                        chat_id: CONFIG.DEFAULT_ADMIN_ID, // Используем DEFAULT_ADMIN_ID, так как он должен быть настроен в Worker
                        text: message,
                        parse_mode: 'HTML'
                    };

                    try {
                        const response = await fetch(workerUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const data = await response.json();
                        if (!data.ok) {
                            console.error("Не удалось отправить уведомление Telegram через Worker:", data.description);
                            VIEW.showNotification(`Ошибка отправки уведомления Telegram: ${data.description}`, "error");
                        } else {
                            console.log("Уведомление Telegram успешно отправлено через Worker.");
                        }
                    } catch (error) {
                        console.error("Ошибка при отправке уведомления Telegram через Worker:", error);
                        VIEW.showNotification("Произошла ошибка при отправке уведомления Telegram через Worker.", "error");
                    }
                },
                // --- КОНЕЦ НОВОЙ ФУНКЦИИ ---

                // Вспомогательная функция для очистки пользовательского ввода от XSS
                sanitizeInput(input) {
                    if (typeof input !== 'string') return input;
                    const map = {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;',
                        '`': '&#x60;'
                    };
                    return input.replace(/[&<>"'`]/g, (match) => map[match]);
                },

                determineUserRole() {
                    const currentTelegramId = STATE.telegramUser.id.toString();
                    if (currentTelegramId === CONFIG.DEFAULT_ADMIN_ID) {
                        STATE.userRole = 'admin';
                    } else if (STATE.users[currentTelegramId]) {
                        STATE.userRole = STATE.users[currentTelegramId].role;
                    } else {
                        STATE.userRole = 'guest';
                    }

                    // Обновляем списки officers и technicians на основе актуальных данных из STATE.users
                    // и начальных данных CONFIG.INITIAL_DATA
                    STATE.officers = Object.values(STATE.users)
                        .filter(u => CONFIG.INITIAL_DATA.officers.includes(u.name) && u.active !== false) // Добавлена проверка на active
                        .map(u => u.name);
                    STATE.technicians = Object.values(STATE.users)
                        .filter(u => CONFIG.INITIAL_DATA.technicians.includes(u.name) && u.active !== false) // Добавлена проверка на active
                        .map(u => u.name);
                    STATE.officians = [...new Set(STATE.officers)].sort();
                    STATE.technicians = [...new Set(STATE.technicians)].sort();
                },

                setupFirestoreListeners() {
                    STATE.unsubscribeListeners.forEach(unsubscribe => unsubscribe());
                    STATE.unsubscribeListeners = [];

                    if (!STATE.db) {
                        return;
                    }

                    const usersRef = collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.USERS_COLLECTION}`);
                    // Слушатель для текущего пользователя (всегда разрешен)
                    const currentUserDocRef = doc(usersRef, STATE.telegramUser.id.toString());
                    STATE.unsubscribeListeners.push(onSnapshot(currentUserDocRef, (docSnapshot) => {
                        if (docSnapshot.exists()) {
                            STATE.users[docSnapshot.id] = docSnapshot.data();
                            this.determineUserRole(); // Переопределяем роль, если изменился текущий пользователь
                            VIEW.renderUserInfo(); // Обновляем информацию о пользователе
                            VIEW.updateManagementSectionVisibility(); // Обновляем видимость секции управления
                            CONTROLLER.setupInputListeners(); // Обновляем состояние кнопок
                        } else {
                            // Если документ текущего пользователя удален или не существует,
                            // переводим его в роль гостя и перерендериваем UI.
                            STATE.userRole = 'guest';
                            VIEW.renderUnauthorized('guest_role');
                        }
                    }, (error) => {
                        console.error("Error listening to current user document:", error);
                        VIEW.showNotification("Ошибка при прослушивании изменений вашего профиля.", "error");
                    }));

                    // Слушатель для всей коллекции пользователей (только для админов)
                    // Этот слушатель будет активен только если пользователь является админом.
                    // Если пользователь не админ, он не сможет получить доступ к этой коллекции,
                    // и это не вызовет ошибку, так как мы не пытаемся получить все документы.
                    if (STATE.userRole === 'admin') {
                        STATE.unsubscribeListeners.push(onSnapshot(usersRef, (snapshot) => {
                            snapshot.docChanges().forEach(change => {
                                STATE.users[change.doc.id] = change.doc.data();
                            });
                            this.determineUserRole();
                            VIEW.renderManagementList();
                            VIEW.renderUserInfo();
                            CONTROLLER.setupInputListeners();
                        }, (error) => {
                            console.error("Error listening to users collection:", error);
                            VIEW.showNotification("Ошибка при прослушивании изменений коллекции пользователей.", "error");
                        }));
                    }


                    const monthDocRef = doc(collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.MONTHS_COLLECTION}`), `${STATE.year}_${STATE.currentMonth}`);
                    STATE.unsubscribeListeners.push(onSnapshot(monthDocRef, (docSnapshot) => {
                        if (docSnapshot.exists()) {
                            const data = docSnapshot.data();
                            STATE.duties[STATE.currentMonth] = data.duties || {};
                            STATE.techDuties[STATE.currentMonth] = data.techDuties || {};
                            STATE.generalSchedule[STATE.currentMonth] = data.generalSchedule || {};
                            STATE.colors = data.colors || {};
                        } else {
                            if (STATE.currentMonth === 6) { // Инициализация данных для июля, если их нет
                                STATE.duties[6] = { ...CONFIG.INITIAL_DATA.julyDuties };
                                STATE.techDuties[6] = JSON.parse(JSON.stringify(CONFIG.INITIAL_DATA.technicianDuties));
                                STATE.generalSchedule[6] = JSON.parse(JSON.stringify(CONFIG.INITIAL_DATA.generalScheduleData));
                                this.saveData(); // Сохраняем начальные данные
                            }
                        }
                        STATE.hasUnsavedChanges = false;
                        VIEW.renderAll();
                    }, (error) => {
                        console.error("Error listening to month data:", error);
                        VIEW.showNotification("Ошибка при прослушивании изменений данных месяца.", "error");
                    }));
                },

                // Новая функция для валидации данных перед сохранением
                validateMonthData(data) {
                    if (!data || typeof data !== 'object') {
                        throw new Error("Некорректный формат данных месяца: ожидается объект.");
                    }
                    if (typeof data.duties !== 'object' || data.duties === null) {
                        throw new Error("Некорректный формат данных дежурств.");
                    }
                    if (typeof data.techDuties !== 'object' || data.techDuties === null) {
                        throw new Error("Некорректный формат данных техников.");
                    }
                    if (typeof data.generalSchedule !== 'object' || data.generalSchedule === null) {
                        throw new Error("Некорректный формат общих данных расписания.");
                    }
                    if (typeof data.colors !== 'object' || data.colors === null) {
                        throw new Error("Некорректный формат данных цветов.");
                    }
                    return true;
                },

                async saveData() {
                    if (!(STATE.userRole === 'admin' || STATE.userRole === 'boss' || STATE.userRole === 'worker')) {
                        VIEW.showNotification('У вас нет прав для сохранения изменений.', 'error');
                        return;
                    }
                    if (!STATE.db) {
                        VIEW.showNotification('База данных не инициализирована. Невозможно сохранить данные.', 'error');
                        return;
                    }

                    VIEW.showLoadingIndicator();
                    const monthDocRef = doc(collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.MONTHS_COLLECTION}`), `${STATE.year}_${STATE.currentMonth}`);
                    
                    try {
                        // Валидация данных перед сохранением
                        this.validateMonthData({
                            duties: STATE.duties[STATE.currentMonth],
                            techDuties: STATE.techDuties[STATE.currentMonth],
                            generalSchedule: STATE.generalSchedule[STATE.currentMonth],
                            colors: STATE.colors
                        });

                        await setDoc(monthDocRef, {
                            duties: STATE.duties[STATE.currentMonth],
                            techDuties: STATE.techDuties[STATE.currentMonth],
                            generalSchedule: STATE.generalSchedule[STATE.currentMonth],
                            colors: STATE.colors
                        }, { merge: true });
                        
                        STATE.hasUnsavedChanges = false;
                        VIEW.showNotification('Изменения успешно сохранены!', 'success');
                    }
                    catch (e) {
                        console.error("Error saving data to Firestore or validation failed:", e);
                        VIEW.showNotification(`Ошибка сохранения данных: ${e.message}`, 'error');
                    } finally {
                        VIEW.hideLoadingIndicator();
                    }
                },

                async changeMonth(newMonth) {
                    if (STATE.hasUnsavedChanges) {
                        VIEW.showConfirmModal('У вас есть несохраненные изменения. Вы уверены, что хотите продолжить без сохранения?').then(confirmed => {
                            if (!confirmed) {
                                VIEW.renderMonthSelector();
                                return;
                            }
                            STATE.currentMonth = parseInt(newMonth, 10);
                            SERVICE.setupFirestoreListeners();
                            VIEW.renderAll();
                            VIEW.renderMonthSelector();
                        });
                    } else {
                        STATE.currentMonth = parseInt(newMonth, 10);
                        SERVICE.setupFirestoreListeners();
                        VIEW.renderAll();
                        VIEW.renderMonthSelector();
                    }
                },

                async toggleEditMode() {
                    if (!(STATE.userRole === 'admin' || STATE.userRole === 'boss' || STATE.userRole === 'worker')) {
                        VIEW.showNotification('У вас нет прав для редактирования.', 'error');
                        return;
                    }
                    
                    if (STATE.isEditMode && STATE.hasUnsavedChanges) {
                        const confirmed = await VIEW.showConfirmModal('У вас есть несохраненные изменения. Сохранить их перед выходом?');
                        if (confirmed) await this.saveData();
                        else this.setupFirestoreListeners();
                    }
                    
                    STATE.isEditMode = !STATE.isEditMode;
                    
                    VIEW.renderAll();

                    if (document.activeElement) {
                        document.activeElement.blur();
                    }

                    VIEW.showNotification(STATE.isEditMode ? 'Режим редактирования включен' : 'Режим просмотра', 'info');
                },

                switchTab(tabName) {
                    STATE.activeTab = tabName;
                    VIEW.renderAll();
                },
                
                handleDayClick(day, calendarType) {
                    STATE.currentSelectedDay = day;
                    if (STATE.isEditMode) {
                        if (calendarType === 'duty') VIEW.showDutyModal();
                        else VIEW.showAssignmentModal(calendarType);
                    } else {
                        VIEW.showEnlargedDayView(day, calendarType);
                    }
                },

                // Helper to get all assignments for a given day across all schedules
                getAllDayAssignments(month, day) {
                    const dayKey = day.toString();
                    const assignments = [];

                    // From duties (single person, implicitly 'ДС')
                    if (STATE.duties[month] && STATE.duties[month][dayKey]) {
                        assignments.push({ person: STATE.duties[month][dayKey], shift: 'ДС' });
                    }

                    // From techDuties (array of objects)
                    if (STATE.techDuties[month] && Array.isArray(STATE.techDuties[month][dayKey])) {
                        STATE.techDuties[month][dayKey].forEach(a => assignments.push(a));
                    }

                    // From generalSchedule (array of objects)
                    if (STATE.generalSchedule[month] && Array.isArray(STATE.generalSchedule[month][dayKey])) {
                        STATE.generalSchedule[month][dayKey].forEach(a => assignments.push(a));
                    }
                    return assignments;
                },

                async assignDuty(person) {
                    const { currentMonth, currentSelectedDay: day } = STATE;
                    const dayKey = day.toString();
                    const assignment = { person, shift: 'ДС' }; // Duty is always 'ДС'

                    const allDayAssignments = this.getAllDayAssignments(currentMonth, day);
                    const existingDsAssignment = allDayAssignments.find(a => a.shift === 'ДС' && a.person === person); // Changed to check for same person

                    if (existingDsAssignment) {
                        VIEW.showNotification(`На ${day} число уже назначен "${existingDsAssignment.person}" на смену "ДС".`, 'info');
                        return;
                    }
                    
                    // Check for night before for the *newly assigned* person
                    const prevDay = (parseInt(day, 10) - 1).toString();
                    let wasNightBefore = false;
                    const prevDayAssignments = this.getAllDayAssignments(currentMonth, prevDay);
                    wasNightBefore = prevDayAssignments.some(a => a.person === person && (a.shift === 'Ночь караул' || a.shift === 'НК'));
                    
                    if (wasNightBefore && assignment.shift !== 'Отсыпной' && assignment.shift !== 'О' && assignment.shift !== 'Выходной' && assignment.shift !== 'В') {
                        const confirmed = await VIEW.showConfirmModal(`${person} был на 'Ночь караул' накануне. Выверены, что хотите лишить его отдыха и поставить на смену '${assignment.shift}'? Это не рекомендуется!`);
                        if (!confirmed) {
                            VIEW.closeModal();
                            return;
                        }
                    }

                    if (person === CONFIG.NO_DUTY_LABEL) {
                        delete STATE.duties[currentMonth][dayKey];
                    } else {
                        STATE.duties[currentMonth][dayKey] = person;
                    }

                    // Sync with general schedule if this is a duty assignment for an officer
                    if (person !== CONFIG.NO_DUTY_LABEL && CONFIG.INITIAL_DATA.officers.includes(person)) {
                        const generalAssignments = STATE.generalSchedule[currentMonth][dayKey] || [];
                        // Remove any existing 'ДС' for this person if they were already there with a different shift
                        const filteredGeneral = generalAssignments.filter(a => !(a.person === person && a.shift === 'ДС'));
                        filteredGeneral.push({ person, shift: 'ДС' });
                        STATE.generalSchedule[currentMonth][dayKey] = filteredGeneral.sort((a, b) => a.person.localeCompare(b.person));
                    } else if (person === CONFIG.NO_DUTY_LABEL) {
                        // If duty is removed, also remove 'ДС' for this person from general schedule
                        if (STATE.generalSchedule[currentMonth] && Array.isArray(STATE.generalSchedule[currentMonth][dayKey])) {
                            STATE.generalSchedule[currentMonth][dayKey] = STATE.generalSchedule[currentMonth][dayKey].filter(a => !(a.person === person && a.shift === 'ДС'));
                            if (STATE.generalSchedule[currentMonth][dayKey].length === 0) delete STATE.generalSchedule[currentMonth][dayKey];
                        }
                    }
                    
                    STATE.hasUnsavedChanges = true;
                    VIEW.closeModal();
                    // Call renderCalendar for specific types
                    VIEW.renderCalendar('duty', day);
                    VIEW.renderCalendar('technician', day);
                    VIEW.renderCalendar('general', day);
                    VIEW.renderStatistics(); // Stats might change, so re-render
                },

                async addAssignment(person, shift, calendarType) {
                    const { currentMonth, currentSelectedDay: day } = STATE;
                    const dayKey = day.toString();
                    const scheduleKey = calendarType === 'technician' ? 'techDuties' : 'generalSchedule';
                    let assignments = STATE[scheduleKey][currentMonth][dayKey] || [];
                    const newAssignment = { person, shift };

                    // Check for existing 'ДС' if the new assignment is 'ДС'
                    if (shift === 'ДС') {
                        const allDayAssignments = this.getAllDayAssignments(currentMonth, day);
                        const existingDsAssignment = allDayAssignments.find(a => a.shift === 'ДС' && a.person === person);

                        if (existingDsAssignment) {
                            VIEW.showNotification(`На ${day} число уже назначен "${existingDsAssignment.person}" на смену "ДС".`, 'info');
                            return;
                        }
                    }
                    
                    // Check for night before for the *newly assigned* person
                    const prevDay = (parseInt(day, 10) - 1).toString();
                    let wasNightBefore = false;
                    const prevDayAssignments = this.getAllDayAssignments(currentMonth, prevDay);
                    wasNightBefore = prevDayAssignments.some(a => a.person === person && (a.shift === 'Ночь караул' || a.shift === 'НК'));
                    
                    if (wasNightBefore && newAssignment.shift !== 'Отсыпной' && newAssignment.shift !== 'О' && newAssignment.shift !== 'Выходной' && newAssignment.shift !== 'В') {
                        const confirmed = await VIEW.showConfirmModal(`${person} был на 'Ночь караул' накануне. Выверены, что хотите лишить его отдыха и поставить на смену '${newAssignment.shift}'? Это не рекомендуется!`);
                        if (!confirmed) {
                            VIEW.closeModal();
                            return;
                        }
                    }

                    // Remove existing assignment for the same person in the current calendar type
                    assignments = assignments.filter(a => a.person !== person);
                    assignments.push(newAssignment);
                    assignments.sort((a, b) => a.person.localeCompare(b.person));
                    STATE[scheduleKey][currentMonth][dayKey] = assignments;

                    this.syncSchedules('add', newAssignment, calendarType);

                    STATE.hasUnsavedChanges = true;
                    VIEW.renderAssignmentModalList(calendarType);
                    // Call renderCalendar for specific types
                    VIEW.renderCalendar('duty', day);
                    VIEW.renderCalendar('technician', day);
                    VIEW.renderCalendar('general', day);
                    VIEW.showNotification('Назначение добавлено!', 'success');
                },

                deleteAssignment(index, calendarType) {
                    const { currentMonth, currentSelectedDay: day } = STATE;
                    const dayKey = day.toString();
                    const scheduleKey = calendarType === 'technician' ? 'techDuties' : 'generalSchedule';
                    const assignments = STATE[scheduleKey][currentMonth][dayKey];

                    if (assignments && index >= 0 && index < assignments.length) {
                        const deletedAssignment = assignments.splice(index, 1)[0];
                        if (assignments.length === 0) {
                            delete STATE[scheduleKey][currentMonth][dayKey];
                        }
                        
                        this.syncSchedules('delete', deletedAssignment, calendarType);

                        STATE.hasUnsavedChanges = true;
                        VIEW.renderAssignmentModalList(calendarType);
                        // Call renderCalendar for specific types
                        VIEW.renderCalendar('duty', day);
                        VIEW.renderCalendar('technician', day);
                        VIEW.renderCalendar('general', day);
                        VIEW.showNotification('Назначение удалено!', 'info');
                    }
                },
                
                syncSchedules(actionType, assignment, sourceCalendar) {
                    const { person, shift } = assignment;
                    const { currentMonth, currentSelectedDay: day } = STATE;
                    const dayKey = day.toString();
                    const isPersonOfficer = CONFIG.INITIAL_DATA.officers.includes(person);
                    const isPersonTechnician = CONFIG.INITIAL_DATA.technicians.includes(person);

                    // If a person is assigned 'ДС' in technician schedule and is an officer, update duty schedule
                    if (sourceCalendar === 'technician' && (person === 'Морозов В.А.' || person === 'Ребраков Т.В.')) {
                        if (shift === 'ДС' && actionType === 'add') {
                            STATE.duties[currentMonth][dayKey] = person;
                        } else if (shift === 'ДС' && actionType === 'delete') {
                            if (STATE.duties[currentMonth][dayKey] === person) delete STATE.duties[currentMonth][dayKey];
                        }
                    }
                    
                    const update = (schedule, key, assign, add) => {
                        const current = schedule[currentMonth][key] || [];
                        let filtered = current.filter(a => !(a.person === assign.person && a.shift === assign.shift));
                        if (add) {
                            filtered.push(assign);
                            filtered.sort((a,b) => a.person.localeCompare(b.person));
                        }
                        if (filtered.length > 0) schedule[currentMonth][key] = filtered;
                        else delete schedule[currentMonth][key];
                    };

                    // Sync technician to general
                    if (sourceCalendar === 'technician') {
                        update(STATE.generalSchedule, dayKey, assignment, actionType === 'add');
                    } 
                    // Sync general to duty/technician based on person's role and shift
                    else if (sourceCalendar === 'general') {
                        if (shift === 'ДС' && isPersonOfficer) {
                            if (actionType === 'add') STATE.duties[currentMonth][dayKey] = person;
                            else if (STATE.duties[currentMonth][dayKey] === person) delete STATE.duties[currentMonth][dayKey];
                        }
                        if (isPersonTechnician && (shift === '8' || shift === 'ДС')) {
                            update(STATE.techDuties, dayKey, assignment, actionType === 'add');
                        }
                    }
                    // Sync duty to general
                    else if (sourceCalendar === 'duty') {
                        if (shift === 'ДС' && isPersonOfficer) {
                             update(STATE.generalSchedule, dayKey, assignment, actionType === 'add');
                        }
                    }
                },

                async addPerson(name, telegramId = null) {
                    if (STATE.userRole !== 'admin') {
                        VIEW.showNotification('Только администратор может добавлять сотрудников.', 'error');
                        return;
                    }
                    const sanitizedName = SERVICE.sanitizeInput(name); // Санитизация имени
                    const sanitizedTelegramId = SERVICE.sanitizeInput(telegramId); // Санитизация Telegram ID

                    if (!sanitizedName || !CONFIG.NAME_REGEX.test(sanitizedName)) {
                        VIEW.showNotification("Введите корректное имя. Примеры: 'Иванов', 'Иванов И.И.', 'Петров-Сидоров А.Б.', 'Анна Мария', 'Смирнов-Лебедев'.", 'error');
                        return;
                    }
                    if (!sanitizedTelegramId || !/^\d+$/.test(sanitizedTelegramId)) {
                        VIEW.showNotification('Telegram ID должен содержать только цифры и быть обязательным.', 'error');
                        return;
                    }
                    if (sanitizedTelegramId.length < 6) {
                        VIEW.showNotification('Telegram ID слишком короткий (минимум 6 цифр).', 'error');
                        return;
                    }
                    if (!STATE.db) {
                        VIEW.showNotification('База данных не инициализирована. Невозможно добавить сотрудника.', 'error');
                        return;
                    }

                    const existingUserByName = Object.values(STATE.users).find(u => u.name === sanitizedName);
                    if (existingUserByName) {
                        VIEW.showNotification('Сотрудник с таким именем уже существует.', 'info');
                        return;
                    }

                    let newId = sanitizedTelegramId.toString();
                    
                    if (STATE.users[newId]) { // Проверка на существование по ID в локальном STATE
                        VIEW.showNotification('Пользователь с таким Telegram ID уже существует.', 'info');
                        return;
                    }

                    const usersRef = collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.USERS_COLLECTION}`);
                    try {
                        // Дополнительная проверка существования в Firestore перед записью
                        const docSnap = await getDoc(doc(usersRef, newId));
                        if (docSnap.exists()) {
                            VIEW.showNotification('Пользователь с таким Telegram ID уже существует в базе данных.', 'info');
                            return;
                        }

                        await setDoc(doc(usersRef, newId), { name: sanitizedName, role: 'worker', active: true }); // Добавлено поле active
                        VIEW.showNotification(`Сотрудник ${sanitizedName} добавлен!`, 'success');
                        VIEW.newOfficerNameInput.value = '';
                        VIEW.newOfficerTelegramIdInput.value = '';
                    } catch (e) {
                        console.error("Error adding person to Firestore:", e);
                        VIEW.showNotification("Ошибка добавления сотрудника.", "error");
                    }
                },

                async deletePerson(personIdToDelete) {
                    if (STATE.userRole !== 'admin') {
                        VIEW.showNotification('У вас нет прав для удаления сотрудников.', 'error');
                        return;
                    }
                    if (personIdToDelete === STATE.telegramUser.id.toString()) {
                        VIEW.showNotification('Вы не можете удалить себя.', 'error');
                        return;
                    }
                    if (!STATE.db) {
                        VIEW.showNotification('База данных не инициализирована. Невозможно удалить сотрудника.', 'error');
                        return;
                    }
                    const personName = STATE.users[personIdToDelete]?.name;
                    if (!personName) {
                        VIEW.showNotification('Сотрудник не найден.', 'error');
                        return;
                    }
                    const confirmed = await VIEW.showConfirmModal(`Вы уверены, что хотите деактивировать сотрудника "${personName}"? Его нельзя будет назначать на новые смены, но история останется.`);
                    if (!confirmed) return;
                    const usersRef = collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.USERS_COLLECTION}`);
                    try {
                        await updateDoc(doc(usersRef, personIdToDelete), { active: false });
                        VIEW.showNotification(`Сотрудник "${personName}" деактивирован.`, 'info');
                    } catch (e) {
                        console.error("Error deactivating person in Firestore:", e);
                        VIEW.showNotification("Ошибка деактивации сотрудника.", "error");
                    }
                },

                async changePersonRole(personId, newRole) {
                    if (STATE.userRole !== 'admin') {
                        VIEW.showNotification('Только администратор может менять роли.', 'error');
                        return;
                    }
                    if (personId === STATE.telegramUser.id.toString()) {
                        VIEW.showNotification('Вы не можете изменить свою собственную роль.', 'error');
                        return;
                    }
                    if (!STATE.db) {
                        VIEW.showNotification('База данных не инициализирована. Невозможно изменить роль.', 'error');
                        return;
                    }
                    if (STATE.users[personId]) {
                        const usersRef = collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.USERS_COLLECTION}`);
                        try {
                            await updateDoc(doc(usersRef, personId), { role: newRole });
                            VIEW.showNotification(`Роль ${STATE.users[personId].name} изменена на ${CONFIG.ROLE_NAMES[newRole]}.`, 'success');
                        } catch (e) {
                            console.error("Error changing person role in Firestore:", e);
                            VIEW.showNotification("Ошибка изменения роли сотрудника.", "error");
                        }
                    } else {
                        VIEW.showNotification('Пользователь не найден для изменения роли.', 'error');
                    }
                },
                
                async clearMonth() {
                    if (!(STATE.userRole === 'admin' || STATE.userRole === 'boss' || STATE.userRole === 'worker')) {
                        VIEW.showNotification('У вас нет прав для очистки месяца.', 'error');
                        return;
                    }
                    let tabName = 'графике';
                    if (STATE.activeTab === 'duty') tabName = 'графике дежурств';
                    else if (STATE.activeTab === 'technician') tabName = 'графике техников';
                    else if (STATE.activeTab === 'general') tabName = 'общем графике';
                    const confirmed = await VIEW.showConfirmModal(`Вы уверены, что хотите очистить все данные для текущего месяца в ${tabName}?`);
                    if (!confirmed) return;

                    const keyMap = { duty: 'duties', technician: 'techDuties', general: 'generalSchedule' };
                    STATE[keyMap[STATE.activeTab]][STATE.currentMonth] = {};
                    await this.saveData();
                    VIEW.renderAll();
                    VIEW.showNotification(`Данные для текущего месяца в ${tabName} очищены.`, 'info');
                },
                
                async cancelChanges() {
                    const confirmed = await VIEW.showConfirmModal('Отменить все несохраненные изменения?');
                    if(confirmed) {
                        this.setupFirestoreListeners();
                        VIEW.showNotification('Изменения отменены.', 'info');
                    }
                },

                async reinitializeApp() {
                    VIEW.showLoadingIndicator();
                    if (STATE.unsubscribeListeners) {
                        STATE.unsubscribeListeners.forEach(unsubscribe => unsubscribe());
                        STATE.unsubscribeListeners = [];
                    }
                    STATE.db = null;
                    STATE.auth = null;
                    STATE.currentUserId = null;
                    STATE.userRole = 'guest';

                    await this.init();
                },

                async generateMonthSummary() {
                    VIEW.showLoadingIndicator();
                    try {
                        const monthName = new Date(STATE.year, STATE.currentMonth).toLocaleString('ru-RU', { month: 'long' });
                        const fullMonthName = `${monthName.charAt(0).toUpperCase() + monthName.slice(1)} ${STATE.year}`;

                        let prompt = `Я предоставляю данные о расписании дежурств за ${fullMonthName}. Пожалуйста, сгенерируйте краткую, но информативную сводку, которая включает:\n`;
                        prompt += `1. Общее количество дежурств/смен для каждого сотрудника за месяц.\n`;
                        prompt += `2. Дни, которые кажутся наиболее загруженными (например, с большим количеством назначений).\n`;
                        prompt += `3. Любые интересные закономерности или наблюдения (например, кто дежурил чаще всего, кто имел много выходных).\n\n`;
                        prompt += `Формат данных:\n`;
                        prompt += `График дежурств:\n[День]: [Имя сотрудника] (если есть)\n\n`;
                        prompt += `График техников:\n[День]: [Имя сотрудника] ([Тип смены]), [Имя сотрудника] ([Тип смены]), ...\n\n`;
                        prompt += `Общий график:\n[День]: [Имя сотрудника] ([Тип смены]), [Имя сотрудника] ([Тип смены]), ...\n\n`;
                        prompt += `Данные для ${fullMonthName}:\n`;

                        const duties = STATE.duties[STATE.currentMonth] || {};
                        if (Object.keys(duties).length > 0) {
                            Object.keys(duties).sort((a,b) => parseInt(a) - parseInt(b)).forEach(day => {
                                prompt += `${day}: ${duties[day]}\n`;
                            });
                        } else {
                            prompt += `Нет данных.\n`;
                        }

                        prompt += `\nГрафик техников:\n`;
                        const techDuties = STATE.techDuties[STATE.currentMonth] || {};
                        if (Object.keys(techDuties).length > 0) {
                            Object.keys(techDuties).sort((a,b) => parseInt(a) - parseInt(b)).forEach(day => {
                                const assignments = techDuties[day].map(a => `${a.person} (${a.shift})`).join(', ');
                                prompt += `${day}: ${assignments}\n`;
                            });
                        } else {
                            prompt += `Нет данных.\n`;
                        }

                        prompt += `\nОбщий график:\n`;
                        const generalSchedule = STATE.generalSchedule[STATE.currentMonth] || {};
                        if (Object.keys(generalSchedule).length > 0) {
                            Object.keys(generalSchedule).sort((a,b) => parseInt(a) - parseInt(b)).forEach(day => {
                                const assignments = generalSchedule[day].map(a => `${a.person} (${a.shift})`).join(', ');
                                prompt += `${day}: ${assignments}\n`;
                            });
                        } else {
                            prompt += `Нет данных.\n`;
                        }

                        prompt += `\nСводка должна быть на русском языке.`;

                        console.log("Sending prompt to proxy:", prompt);

                        // Вызов прокси-сервиса
                        const response = await fetch("https://gemini-proxy.ik2grafik.workers.dev", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                prompt: prompt,
                            }),
                        });
                        const data = await response.json();
                        
                        // Парсинг ответа, как указано
                        const summaryText = data?.candidates?.[0]?.content?.parts?.[0]?.text;

                        if (summaryText) {
                            VIEW.showSummaryModal(summaryText, fullMonthName);
                        } else {
                            VIEW.showNotification('Не удалось сгенерировать сводку. Попробуйте еще раз.', 'error');
                            console.error("Proxy response structure unexpected or summary missing:", data);
                        }
                    } catch (e) {
                        console.error("Error calling Gemini proxy:", e);
                        VIEW.showNotification('Ошибка при обращении к Gemini прокси: ' + (e.message || 'Неизвестная ошибка'), 'error');
                    } finally {
                        VIEW.hideLoadingIndicator();
                    }
                },

                changeYear(newYear) {
                    STATE.year = parseInt(newYear, 10);
                    SERVICE.setupFirestoreListeners();
                    VIEW.renderAll();
                    VIEW.renderMonthSelector();
                }
            };

            /**
             * VIEW: Отвечает за все манипуляции с DOM. Только читает из STATE.
             */
            const VIEW = {
                // DOM elements references, initialized after renderAppShell
                // Static elements referenced directly at the top of the IIFE
                loadingIndicator: loadingIndicatorElement,
                editModalOverlay: editModalOverlayElement,
                editModalTitle: editModalTitleElement,
                editModalBody: editModalBodyElement,
                viewModalOverlay: viewModalOverlayElement,
                viewModalTitle: viewModalTitleElement,
                viewModalBody: viewModalBodyElement,
                confirmModalOverlay: confirmModalOverlayElement,
                confirmModalMessage: confirmModalMessageElement,
                confirmModalConfirmBtn: confirmModalConfirmBtnElement,
                confirmModalCancelBtn: confirmModalCancelBtnElement,
                summaryModalOverlay: summaryModalOverlayElement,
                summaryModalTitle: summaryModalTitleElement,
                summaryModalBody: summaryModalBodyElement,

                // Elements inside appContainer, initialized by initAppElements
                newOfficerNameInput: null,
                newOfficerTelegramIdInput: null,
                dutyCalendarGrid: null,
                technicianCalendarGrid: null,
                generalCalendarGrid: null,
                statsList: null,
                currentOfficersList: null,
                actionButtonsWrapper: null,
                tabNavigation: null,
                toggleEditModeBtn: null,
                statisticsSection: null,
                managementSection: null,
                addPersonBtn: null, // Добавлено для ссылки на кнопку "Добавить"
            };

            VIEW.init = function() {
                this.initAppElements();
                this.renderAll();
            };
            
            VIEW.renderAppShell = function() {
                const container = document.querySelector(CONFIG.DOM_SELECTORS.container);
                if (!container) {
                    console.error("Error: App container not found. Cannot render app shell.");
                    return;
                }
                container.innerHTML = `
                    <header class="header">
                        <div class="user-info" id="userInfo"></div>
                        <h1>Календарь дежурств</h1>
                        <div class="month-year-selectors">
                            <div class="custom-dropdown" id="monthDropdown">
                                <div class="dropdown-selected" id="monthDropdownSelected"></div>
                                <div class="dropdown-list" id="monthDropdownList"></div>
                            </div>
                            <div class="custom-dropdown" id="yearDropdown">
                                <div class="dropdown-selected" id="yearDropdownSelected"></div>
                                <div class="dropdown-list" id="yearDropdownList"></div>
                            </div>
                        </div>
                    </header>
                    <main class="main-content">
                        <nav class="tab-navigation" id="tabNavigation">
                            <button class="tab-button active btn" data-tab="duty">График дежурств</button>
                            <button class="tab-button btn" data-tab="technician">График техников</button>
                            <button class="tab-button btn" data-tab="general">Общий график</button>
                        </nav>
                        <div class="section-container">
                            <div id="dutyTab" class="tab-content active"><div class="calendar-grid" id="dutyCalendarGrid" data-calendar-type="duty"></div></div>
                            <div id="technicianTab" class="tab-content"><div class="calendar-grid" id="technicianCalendarGrid" data-calendar-type="technician"></div></div>
                            <div id="generalTab" class="tab-content"><div class="calendar-grid" id="generalCalendarGrid" data-calendar-type="general"></div></div>
                        </div>
                        <div id="editModeBtnWrapper" style="display:flex;justify-content:center;margin:18px 0 0 0;">
                            <button class="btn btn--edit-mode" id="toggleEditModeBtn" data-action="toggleEditMode">Редактировать</button>
                        </div>
                        <div class="action-buttons-wrapper hidden" id="actionButtons">
                            <button class="btn btn--save" data-action="save">Сохранить изменения</button>
                            <button class="btn btn--cancel" data-action="cancel">Отменить изменения</button>
                            <button class="btn btn--clear" data-action="clear">Очистить месяц</button>
                        </div>
                        <button class="btn btn--toggle" data-action="toggleSection" data-target="statisticsSection">Статистика</button>
                        <div class="section-container hidden-section" id="statisticsSection">
                            <h3>Статистика дежурств</h3>
                            <div class="stats-list" id="statsList"></div>
                            <button class="btn btn--blue" style="margin-top: 15px;" data-action="generateMonthSummary">✨ Сгенерировать сводку за месяц</button>
                        </div>
                        <button class="btn btn--toggle" data-action="toggleSection" data-target="managementSection" style="margin-top: 10px;">Управление</button>
                        <div class="section-container hidden-section" id="managementSection">
                            <h3>Управление персоналом</h3>
                            <div class="officer-management-controls">
                                <input type="text" id="newOfficerName" placeholder="Имя нового сотрудника (Фамилия И.О.)">
                                <input type="text" id="newOfficerTelegramId" placeholder="Telegram ID (обязательно)">
                                <button class="btn btn--save" data-action="addPerson">Добавить</button>
                            </div>
                            <div class="current-officers-list" id="currentOfficersList"></div>
                        </div>
                    </main>`;
                this.renderUserInfo();
            };

            VIEW.renderMonthSelector = function() {
                const monthNames = [];
                for (let i = 0; i < 12; i++) {
                    monthNames.push(new Date(STATE.year, i).toLocaleString('ru-RU', { month: 'long' }));
                }
                const monthDropdownSelected = document.getElementById('monthDropdownSelected');
                const monthDropdownList = document.getElementById('monthDropdownList');
                if (monthDropdownSelected && monthDropdownList) {
                    monthDropdownSelected.textContent = monthNames[STATE.currentMonth].charAt(0).toUpperCase() + monthNames[STATE.currentMonth].slice(1);
                    monthDropdownList.innerHTML = '';
                    monthNames.forEach((name, i) => {
                        const item = document.createElement('div');
                        item.className = 'dropdown-item' + (i === STATE.currentMonth ? ' selected' : '');
                        item.textContent = name.charAt(0).toUpperCase() + name.slice(1);
                        item.dataset.value = i;
                        item.addEventListener('click', () => {
                            SERVICE.changeMonth(i);
                            monthDropdownList.classList.remove('show');
                        });
                        monthDropdownList.appendChild(item);
                    });
                }
                const yearDropdownSelected = document.getElementById('yearDropdownSelected');
                const yearDropdownList = document.getElementById('yearDropdownList');
                if (yearDropdownSelected && yearDropdownList) {
                    yearDropdownSelected.textContent = STATE.year;
                    yearDropdownList.innerHTML = '';
                    for (let y = 2024; y <= 2026; y++) {
                        const item = document.createElement('div');
                        item.className = 'dropdown-item' + (y === STATE.year ? ' selected' : '');
                        item.textContent = y;
                        item.dataset.value = y;
                        item.addEventListener('click', () => {
                            SERVICE.changeYear(y);
                            yearDropdownList.classList.remove('show');
                        });
                        yearDropdownList.appendChild(item);
                    }
                }
            };

            document.addEventListener('click', function(e) {
                document.querySelectorAll('.custom-dropdown').forEach(drop => {
                    if (!drop.contains(e.target)) {
                        drop.querySelector('.dropdown-list')?.classList.remove('show');
                    }
                });
            });
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('dropdown-selected')) {
                    const list = e.target.nextElementSibling;
                    if (list) list.classList.toggle('show');
                }
            });

            VIEW.initAppElements = function() {
                // Get elements that are part of the dynamically rendered app shell
                const dynamicSelectors = {
                    newOfficerNameInput: CONFIG.DOM_SELECTORS.newOfficerName,
                    newOfficerTelegramIdInput: CONFIG.DOM_SELECTORS.newOfficerTelegramId,
                    dutyCalendarGrid: CONFIG.DOM_SELECTORS.dutyCalendarGrid,
                    technicianCalendarGrid: CONFIG.DOM_SELECTORS.technicianCalendarGrid,
                    generalCalendarGrid: CONFIG.DOM_SELECTORS.generalCalendarGrid,
                    statsList: CONFIG.DOM_SELECTORS.statsList,
                    currentOfficersList: CONFIG.DOM_SELECTORS.currentOfficersList,
                    actionButtonsWrapper: CONFIG.DOM_SELECTORS.actionButtons,
                    tabNavigation: CONFIG.DOM_SELECTORS.tabNavigation,
                    toggleEditModeBtn: '#toggleEditModeBtn',
                    statisticsSection: '#statisticsSection',
                    managementSection: '#managementSection',
                    addPersonBtn: '[data-action="addPerson"]', // Добавлено для ссылки на кнопку "Добавить"
                };

                for (const key in dynamicSelectors) {
                    if (dynamicSelectors.hasOwnProperty(key)) {
                        const selector = dynamicSelectors[key];
                        this[key] = document.querySelector(selector);
                        if (!this[key]) {
                            const errorMessage = `Ошибка инициализации DOM: Элемент '${selector}' (ключ: ${key}) не найден.`;
                            console.error(errorMessage);
                            throw new Error(errorMessage);
                        }
                    }
                }
            };

            VIEW.showLoadingIndicator = function() {
                if (this.loadingIndicator) this.loadingIndicator.style.display = 'flex';
            };

            VIEW.hideLoadingIndicator = function() {
                if (this.loadingIndicator) this.loadingIndicator.style.display = 'none';
            };

            VIEW.renderUserInfo = function() {
                const userInfoContainer = document.getElementById('userInfo');
                if (userInfoContainer) {
                    const { first_name, username, id } = STATE.telegramUser;
                    const roleText = CONFIG.ROLE_NAMES[STATE.userRole] || 'Неизвестно';
                    userInfoContainer.innerHTML = `Вы вошли как <span>${SERVICE.sanitizeInput(first_name)}</span> (@${SERVICE.sanitizeInput(username)}) | ID: <span>${SERVICE.sanitizeInput(id.toString())}</span> | Роль: <span>${roleText}</span>`;
                }
                // Обновляем видимость секции управления персоналом
                this.updateManagementSectionVisibility();
            };

            VIEW.renderUnauthorized = function(reason) {
                const container = document.querySelector(CONFIG.DOM_SELECTORS.container);
                if (!container) {
                    console.error("Error: App container not found for unauthorized view.");
                    return;
                }
                let messageHtml = '';
                if (reason === 'auth_failed') {
                    messageHtml = `
                        <h1>Ошибка аутентификации</h1>
                        <p>Не удалось войти в систему. Возможно, Firebase Authentication не включен для вашего проекта в консоли Firebase.</p>
                        <p>Пожалуйста, перейдите в <a href="https://console.firebase.google.com/" target="_blank">консоль Firebase</a>, выберите ваш проект "ik2grafik", затем раздел "Authentication" и убедитесь, что хотя бы один метод входа включен (например, "Anonymous" или "Email/Password").</p>
                        <p>После этого попробуйте перезапустить приложение.</p>
                    `;
                } else if (reason === 'guest_role') {
                    messageHtml = `
                        <h1>Доступ ограничен</h1>
                        <p>Ваша заявка на доступ ожидает одобрения администратором.</p>
                        <p>Ваш Telegram ID: <strong>${SERVICE.sanitizeInput(STATE.telegramUser?.id.toString() || 'Неизвестно')}</strong></p>
                        <p>Пожалуйста, сообщите его администратору для получения доступа.</p>
                    `;
                } else if (reason === 'telegram_auth_failed') {
                    messageHtml = `
                        <h1>Ошибка авторизации Telegram</h1>
                        <p>Не удалось подтвердить подпись данных Telegram WebApp.</p>
                        <p>Пожалуйста, убедитесь, что вы открываете приложение через официальный клиент Telegram и попробуйте еще раз.</p>
                        <p>Если проблема сохраняется, обратитесь к администратору.</p>
                    `;
                } else if (reason === 'unhandled_error') {
                    messageHtml = `
                        <h1>Произошла ошибка</h1>
                        <p>Приложение столкнулось с неожиданной ошибкой во время инициализации. Пожалуйста, попробуйте перезагрузить страницу или свяжитесь с администратором.</p>
                    `;
                } else {
                    messageHtml = `
                        <h1>Доступ ограничен</h1>
                        <p>Неизвестная причина ограничения доступа.</p>
                    `;
                }

                container.innerHTML = `<div class="unauthorized">${messageHtml}</div>`;
                this.hideLoadingIndicator();
            };

            VIEW.renderAll = function() {
                this.renderMonthSelector();
                this.renderTabsAndButtons(); // Вызов новой функции
                this.renderAllCalendars();
                this.renderStatistics();
                this.renderManagementList();
            };

            // Новая функция для рендеринга вкладок и кнопок действий
            VIEW.renderTabsAndButtons = function() {
                // 1) Скрываем/показываем кнопку редактирования
                const editBtn = this.toggleEditModeBtn; // Используем ссылку из VIEW
                if (editBtn) { // Проверяем, что кнопка существует
                    if (STATE.userRole !== 'admin' && STATE.userRole !== 'boss') {
                        editBtn.style.display = 'none';
                    } else {
                        editBtn.style.display = ''; // вернуть default (flex в данном случае)
                    }
                }

                if (this.tabNavigation) {
                    // Update active tab button
                    this.tabNavigation.querySelectorAll('.tab-button').forEach(button => {
                        if (button.dataset.tab === STATE.activeTab) {
                            button.classList.add('active');
                        } else {
                            button.classList.remove('active');
                        }
                    });
                    // Show/hide tab content
                    document.querySelectorAll('.tab-content').forEach(content => {
                        if (content.id === `${STATE.activeTab}Tab`) {
                            content.classList.add('active');
                        } else {
                            content.classList.remove('active');
                        }
                    });
                }

                if (this.actionButtonsWrapper) {
                    if (STATE.isEditMode) {
                        this.actionButtonsWrapper.classList.remove('hidden');
                    } else {
                        this.actionButtonsWrapper.classList.add('hidden');
                    }
                }

                if (this.toggleEditModeBtn) {
                    this.toggleEditModeBtn.textContent = STATE.isEditMode ? 'Завершить редактирование' : 'Редактировать';
                    if (!(STATE.userRole === 'admin' || STATE.userRole === 'boss' || STATE.userRole === 'worker')) {
                        this.toggleEditModeBtn.disabled = true;
                    } else {
                        this.toggleEditModeBtn.disabled = false;
                    }
                }
            };

            VIEW.renderAllCalendars = function() {
                this.renderCalendar('duty');
                this.renderCalendar('technician');
                this.renderCalendar('general');
            };
            
            VIEW.renderCalendar = function(calendarType, changedDay = null) {
                const grid = this[`${calendarType}CalendarGrid`];
                if (!grid) return;

                const dataMap = { duty: STATE.duties, technician: STATE.techDuties, general: STATE.generalSchedule };
                const monthData = dataMap[calendarType][STATE.currentMonth] || {};
                
                if (changedDay === null) {
                    // Full re-render if no specific day is provided
                    const fragment = document.createDocumentFragment();
                    ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'].forEach(day => {
                        const header = document.createElement('div');
                        header.className = 'day-header';
                        header.textContent = day;
                        fragment.appendChild(header);
                    });

                    const firstDayOfMonth = new Date(STATE.year, STATE.currentMonth, 1);
                    const daysInMonth = new Date(STATE.year, STATE.currentMonth + 1, 0).getDate();
                    const firstDayOfWeek = (firstDayOfMonth.getDay() + 6) % 7;

                    for (let i = 0; i < firstDayOfWeek; i++) {
                        fragment.appendChild(document.createElement('div')).className = 'day-cell empty';
                    }

                    const today = new Date();
                    for (let day = 1; day <= daysInMonth; day++) {
                        const cell = document.createElement('div');
                        cell.className = 'day-cell';
                        cell.dataset.day = day;
                        
                        const date = new Date(STATE.year, STATE.currentMonth, day);
                        const dayOfWeek = (date.getDay() + 6) % 7;
                        if (dayOfWeek >= 5) cell.classList.add('weekend');
                        if (date.toDateString() === today.toDateString()) cell.classList.add('current-day');
                        
                        cell.innerHTML = `<div class="day-number">${day}</div><div class="day-entries-container"></div>`;
                        
                        const dayAssignments = monthData[day] || [];
                        const assignmentsArray = Array.isArray(dayAssignments) ? dayAssignments : (typeof dayAssignments === 'string' ? [{ person: dayAssignments, shift: '' }] : []);
                        
                        const entriesContainer = cell.querySelector('.day-entries-container');
                        entriesContainer.innerHTML = ''; // Clear existing entries before appending
                        entriesContainer.appendChild(this.createDayEntry(assignmentsArray));
                        
                        fragment.appendChild(cell);
                    }
                    
                    grid.innerHTML = '';
                    grid.appendChild(fragment);
                } else {
                    // Partial update for a specific day
                    const cell = grid.querySelector(`.day-cell[data-day="${changedDay}"]`);
                    if (cell) {
                        const entriesContainer = cell.querySelector('.day-entries-container');
                        entriesContainer.innerHTML = ''; // Clear existing entries

                        const dayAssignments = monthData[changedDay] || [];
                        const assignmentsArray = Array.isArray(dayAssignments) ? dayAssignments : (typeof dayAssignments === 'string' ? [{ person: dayAssignments, shift: '' }] : []);
                        
                        entriesContainer.appendChild(this.createDayEntry(assignmentsArray));
                    }
                }
            };
            
            VIEW.createDayEntry = function(assignmentsArray) {
                const fragment = document.createDocumentFragment();

                function getShiftShort(shift) {
                    if (!shift) return '';
                    const map = {
                        'День караул': 'ДК',
                        'Ночь караул': 'НК',
                        'Отпуск': 'ОТ',
                        'Больничный': 'БЛ',
                        'Выходной': 'В',
                        'Отсыпной': 'О',
                        'ДС': 'ДС',
                        '8': '8'
                    };
                    return map[shift] || shift.slice(0, 2).toUpperCase();
                }

                if (assignmentsArray.length === 0) {
                    const emptyEntry = document.createElement('div');
                    emptyEntry.className = 'avatar-initials avatar-empty';
                    fragment.appendChild(emptyEntry);
                    return fragment;
                }

                assignmentsArray.forEach(assignment => {
                    const person = assignment.person;
                    const shift = assignment.shift;
                    let initials = '';
                    if (person) {
                        const parts = person.split(' ');
                        if (parts.length > 1) {
                            initials = (parts[0][0] || '').toUpperCase() + (parts[1][0] || '').toUpperCase();
                        } else {
                            initials = (person[0] || '').toUpperCase();
                        }
                    }
                    const shortShift = getShiftShort(shift);
                    const entry = document.createElement('div');
                    
                    // Apply class based on number of assignments
                    if (assignmentsArray.length === 1) {
                        entry.className = 'avatar-initials avatar-single';
                    } else if (assignmentsArray.length === 2) {
                        entry.className = 'avatar-initials avatar-two';
                    } else {
                        entry.className = 'avatar-initials avatar-multiple';
                    }

                    entry.title = shift ? `${SERVICE.sanitizeInput(person)} (${SERVICE.sanitizeInput(shift)})` : SERVICE.sanitizeInput(person);
                    const personColor = this.getColorFor(person);
                    entry.style.backgroundColor = personColor;
                    entry.style.color = this.isLightColor(personColor) ? '#333' : '#fff';

                    entry.innerHTML = `
                        <span class="avatar-letters">${SERVICE.sanitizeInput(initials)}</span>
                        ${shift ? `<span class="avatar-shift">${SERVICE.sanitizeInput(shortShift)}</span>` : ''}
                    `;
                    fragment.appendChild(entry);
                });
                return fragment;
            };

            VIEW.renderStatistics = function() {
                const stats = {};
                STATE.officers.filter(o => o !== CONFIG.NO_DUTY_LABEL).forEach(officer => {
                    stats[officer] = 0;
                });
                
                Object.values(STATE.duties[STATE.currentMonth] || {}).forEach(officer => {
                    if (officer && officer !== CONFIG.NO_DUTY_LABEL) {
                        stats[officer] = (stats[officer] || 0) + 1;
                    }
                });
                
                const sortedOfficers = Object.keys(stats).sort((a, b) => stats[b] - stats[a] || a.localeCompare(b));
                
                const statsList = this.statsList;
                if (!statsList) return;
                statsList.innerHTML = '';
                sortedOfficers.forEach(officer => {
                    const item = document.createElement('div');
                    item.className = 'stats-item';
                    const color = this.getColorFor(officer);
                    item.innerHTML = `<div class="stats-name" style="background-color:${color}; color:${this.isLightColor(color) ? '#333' : '#fff'}">${SERVICE.sanitizeInput(officer)}</div>
                                      <div class="stats-count">${stats[officer]}</div>`;
                    statsList.appendChild(item);
                });
            };
            
            VIEW.renderManagementList = function() {
                const list = this.currentOfficersList;
                if (!list) return;

                // Скрыть или показать секцию управления в зависимости от роли
                this.updateManagementSectionVisibility();

                let searchInput = document.getElementById('officerSearchInput');
                if (!searchInput) {
                    searchInput = document.createElement('input');
                    searchInput.type = 'text';
                    searchInput.id = 'officerSearchInput';
                    searchInput.placeholder = 'Поиск сотрудника...';
                    searchInput.style.margin = '0 0 10px 0';
                    searchInput.style.padding = '8px 12px';
                    searchInput.style.borderRadius = '8px';
                    searchInput.style.border = '1px solid var(--border-main)';
                    searchInput.style.width = '100%';
                    list.parentNode.insertBefore(searchInput, list);
                }
                const filter = (searchInput.value || '').toLowerCase();
                const allUsers = Object.entries(STATE.users).sort(([, a], [, b]) => (a.name || '').localeCompare(b.name || ''));
                const filteredUsers = filter ? allUsers.filter(([, u]) => (u.name || '').toLowerCase().includes(filter)) : allUsers;
                list.innerHTML = '';
                filteredUsers.forEach(([id, userData]) => {
                    // Если пользователь деактивирован, не показываем его в списке
                    if (userData.active === false) return; 

                    const item = document.createElement('div');
                    item.className = 'current-officer-item';
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'person-name';
                    nameSpan.textContent = SERVICE.sanitizeInput(userData.name || 'Неизвестное имя') + (userData.active === false ? ' (неактивен)' : '');
                    const idSpan = document.createElement('span');
                    idSpan.className = 'telegram-id';
                    idSpan.textContent = ` (ID: ${SERVICE.sanitizeInput(id)})`;
                    item.appendChild(nameSpan);
                    item.appendChild(idSpan);
                    const roleSelect = document.createElement('select');
                    roleSelect.className = 'role-selector';
                    roleSelect.dataset.personId = id;
                    
                    // Доступные роли для назначения в зависимости от текущей роли пользователя
                    const availableRoles = STATE.userRole === 'admin' ? ['admin', 'boss', 'worker', 'guest'] :
                                           (STATE.userRole === 'boss' ? ['worker', 'guest'] : ['guest']);

                    availableRoles.forEach(role => {
                        const option = document.createElement('option');
                        option.value = role;
                        option.textContent = CONFIG.ROLE_NAMES[role];
                        if (userData.role === role) {
                            option.selected = true;
                        }
                        roleSelect.appendChild(option);
                    });
                    // Отключение селектора ролей, если текущий пользователь не админ, или пытается изменить свою роль,
                    // или пользователь деактивирован.
                    if (STATE.userRole !== 'admin' || id === STATE.telegramUser.id.toString() || userData.active === false) {
                        roleSelect.disabled = true;
                    }
                    roleSelect.addEventListener('change', (e) => {
                        SERVICE.changePersonRole(e.target.dataset.personId, e.target.value);
                    });
                    item.appendChild(roleSelect);
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-officer-btn';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.title = `Деактивировать ${SERVICE.sanitizeInput(userData.name || 'пользователя')}`;
                    deleteBtn.dataset.action = 'deletePerson';
                    deleteBtn.dataset.personIdToDelete = id;
                    if (STATE.userRole !== 'admin' || id === STATE.telegramUser.id.toString() || userData.active === false) {
                        deleteBtn.disabled = true;
                    }
                    item.appendChild(deleteBtn);
                    list.appendChild(item);
                });
                searchInput.oninput = () => this.renderManagementList();

                // Обновление состояния кнопки "Добавить"
                if (this.addPersonBtn) {
                    this.addPersonBtn.disabled = STATE.userRole === 'admin' ? false : true; // Only admin can add
                    this.addPersonBtn.title = STATE.userRole === 'admin' ? "" : "Только администратор может добавлять сотрудников";
                }
            };

            // Новая функция для управления видимостью секции управления персоналом
            VIEW.updateManagementSectionVisibility = function() {
                if (this.managementSection) {
                    const toggleButton = document.querySelector('[data-action="toggleSection"][data-target="managementSection"]');
                    if (STATE.userRole === 'admin' || STATE.userRole === 'boss') {
                        this.managementSection.style.display = 'block'; // Показываем секцию
                        if (toggleButton) toggleButton.style.display = 'block'; // Показываем кнопку переключения
                    } else {
                        this.managementSection.style.display = 'none'; // Скрываем секцию
                        if (toggleButton) toggleButton.style.display = 'none'; // Скрываем кнопку переключения
                    }
                }
            };

            const TECHNICIANS_GROUP = ["Денщиков А.А.", "Кузавлев П.С.", "Лебедев А.В."];

            VIEW.showDutyModal = function() {
                const modal = this.editModalBody;
                if (!modal) return;
                this.editModalTitle.textContent = 'Выберите дежурного';
                
                const currentAssignment = STATE.duties[STATE.currentMonth][STATE.currentSelectedDay];
                const allAssignedPeopleOnDay = new Set(SERVICE.getAllDayAssignments(STATE.currentMonth, STATE.currentSelectedDay).map(a => a.person));

                // Filter officers: only show those not assigned anywhere else, or the current selected officer
                const availableOfficers = STATE.officers.filter(name => 
                    !allAssignedPeopleOnDay.has(name) || name === currentAssignment
                );

                const optionsHTML = [...availableOfficers, CONFIG.NO_DUTY_LABEL].map(name => {
                    const isSelected = (name === currentAssignment || (!currentAssignment && name === CONFIG.NO_DUTY_LABEL));
                    return `<button class="officer-option btn ${isSelected ? 'selected' : ''}" data-action="selectDuty" data-name="${SERVICE.sanitizeInput(name)}">${SERVICE.sanitizeInput(name)}</button>`;
                }).join('');
                
                modal.innerHTML = `<div class="officer-list">${optionsHTML}</div>`;
                this.openModal('edit');
            };

            VIEW.showAssignmentModal = function(calendarType) {
                const modal = this.editModalBody;
                if (!modal) return;
                this.editModalTitle.textContent = `Назначить смену на ${STATE.currentSelectedDay}-е число`;
                modal.dataset.calendarType = calendarType;

                const officers = STATE.officers.filter(n => !TECHNICIANS_GROUP.includes(n));
                const technicians = TECHNICIANS_GROUP.filter(n => STATE.technicians.includes(n));
                const workers = Object.values(STATE.users)
                    .filter(u => u.role === 'worker' && !officers.includes(u.name) && !technicians.includes(u.name) && u.active !== false)
                    .map(u => u.name)
                    .sort();

                const TECHNICIAN_FIVE = ["Морозов В.А.", "Ребраков Т.В.", "Кузавлев П.С.", "Лебедев А.В.", "Денщиков А.А."];

                let allPossiblePeople = [];
                if (calendarType === 'duty') {
                    allPossiblePeople = officers;
                } else if (calendarType === 'technician') {
                    allPossiblePeople = TECHNICIAN_FIVE;
                } else if (calendarType === 'general') {
                    allPossiblePeople = [...officers, ...technicians, ...workers];
                }

                const day = STATE.currentSelectedDay;
                const currentMonth = STATE.currentMonth;
                const allDayAssignments = SERVICE.getAllDayAssignments(currentMonth, day);
                const allAssignedPeopleOnDay = new Set(allDayAssignments.map(a => a.person));

                // Filter people for the dropdown: only show those not assigned anywhere else for this day
                const peopleForDropdown = allPossiblePeople.filter(p => !allAssignedPeopleOnDay.has(p));

                // Add current assignments for THIS specific calendar back to the list if they are being edited
                const currentAssignmentsForThisCalendar = (calendarType === 'technician' ? STATE.techDuties[currentMonth][day] : STATE.generalSchedule[currentMonth][day]) || [];
                currentAssignmentsForThisCalendar.forEach(assignment => {
                    if (!peopleForDropdown.includes(assignment.person)) {
                        peopleForDropdown.push(assignment.person);
                    }
                });
                peopleForDropdown.sort((a,b) => a.localeCompare(b));


                let peopleOptionsHTML = '';
                if (calendarType === 'general') {
                    const officersForDropdown = peopleForDropdown.filter(p => officers.includes(p));
                    const techniciansForDropdown = peopleForDropdown.filter(p => technicians.includes(p));
                    const workersForDropdown = peopleForDropdown.filter(p => workers.includes(p));

                    if (officersForDropdown.length) {
                        peopleOptionsHTML += '<optgroup label="Офицеры">' + officersForDropdown.map(p => `<option value="${SERVICE.sanitizeInput(p)}">${SERVICE.sanitizeInput(p)}</option>`).join('') + '</optgroup>';
                    }
                    if (techniciansForDropdown.length) {
                        peopleOptionsHTML += '<optgroup label="Техники">' + techniciansForDropdown.map(p => `<option value="${SERVICE.sanitizeInput(p)}">${SERVICE.sanitizeInput(p)}</option>`).join('') + '</optgroup>';
                    }
                    if (workersForDropdown.length) {
                        peopleOptionsHTML += '<optgroup label="Работяги">' + workersForDropdown.map(p => `<option value="${SERVICE.sanitizeInput(p)}">${SERVICE.sanitizeInput(p)}</option>`).join('') + '</optgroup>';
                    }
                } else {
                    peopleOptionsHTML = peopleForDropdown.map(p => `<option value="${SERVICE.sanitizeInput(p)}">${SERVICE.sanitizeInput(p)}</option>`).join('');
                }

                const personSelectId = 'personSelect';
                const shiftSelectId = 'shiftSelect';
                const shiftsForSelect = CONFIG.SHIFT_TYPES;
                let shiftOptionsHTML = '';
                if (calendarType === 'technician') {
                    shiftOptionsHTML = shiftsForSelect.map((s, i) => {
                        if (s === 'ДС') {
                            return `<option value="${SERVICE.sanitizeInput(s)}" ${i === 0 ? 'selected' : ''} disabled>${SERVICE.sanitizeInput(s)}</option>`;
                        } else {
                            return `<option value="${SERVICE.sanitizeInput(s)}" ${i === 0 ? 'selected' : ''}>${SERVICE.sanitizeInput(s)}</option>`;
                        }
                    }).join('');
                } else {
                    shiftOptionsHTML = shiftsForSelect.map((s, i) => `<option value="${SERVICE.sanitizeInput(s)}" ${i === 0 ? 'selected' : ''}>${SERVICE.sanitizeInput(s)}</option>`).join('');
                }

                modal.innerHTML = `
                    <div class="assignment-controls">
                        <select id="${personSelectId}">${peopleOptionsHTML}</select>
                        <select id="${shiftSelectId}">${shiftOptionsHTML}</select>
                        <button class="btn btn--save" data-action="addAssignment">Добавить назначение</button>
                    </div>
                    <div class="assignments-list-container">
                        <h5>Текущие назначения:</h5>
                        <div id="assignmentsList"></div>
                    </div>`;
                this.renderAssignmentModalList(calendarType);
                this.openModal('edit');
                setTimeout(() => {
                    const personSelect = modal.querySelector('#personSelect');
                    if (personSelect) personSelect.focus();
                    const shiftSelect = modal.querySelector('#shiftSelect');
                    if (calendarType === 'technician' && personSelect && shiftSelect) {
                        personSelect.onchange = function() {
                            const selectedName = personSelect.value;
                            Array.from(shiftSelect.options).forEach(opt => {
                                if (opt.value === 'ДС') {
                                    opt.disabled = !(selectedName === 'Морозов В.А.' || selectedName === 'Ребраков Т.В.');
                                }
                            });
                            if (shiftSelect.value === 'ДС' && shiftSelect.options[shiftSelect.selectedIndex].disabled) {
                                shiftSelect.value = shiftSelect.options[0].value;
                            }
                        };
                        personSelect.onchange();
                    }
                    if (calendarType === 'general' && personSelect && shiftSelect) {
                        personSelect.onchange = function() {
                            const selectedName = personSelect.value;
                            if (TECHNICIANS_GROUP.includes(selectedName) || workers.includes(selectedName)) {
                                Array.from(shiftSelect.options).forEach(opt => {
                                    if (opt.value === 'ДС') opt.disabled = true;
                                    else opt.disabled = false;
                                });
                                if (shiftSelect.value === 'ДС') shiftSelect.value = shiftSelect.options[0].value;
                            } else {
                                Array.from(shiftSelect.options).forEach(opt => { opt.disabled = false; });
                            }
                        };
                        personSelect.onchange();
                    }
                }, 0);
            };

            VIEW.showEnlargedDayView = function(day, calendarType) {
                const { year, currentMonth } = STATE;
                const fullDate = new Date(year, currentMonth, day).toLocaleString('ru-RU', { day: 'numeric', month: 'long', year: 'numeric' });
                this.viewModalTitle.textContent = fullDate;
                const body = this.viewModalBody;
                if (!body) return;
                body.innerHTML = '';

                // Collect all unique assignments for the day
                const uniqueAssignments = new Map(); // Map to store unique person -> {person, shift}

                const allDayAssignments = SERVICE.getAllDayAssignments(currentMonth, day);
                allDayAssignments.forEach(assignment => {
                    const key = `${assignment.person} (${assignment.shift})`;
                    if (!uniqueAssignments.has(key)) {
                        uniqueAssignments.set(key, assignment);
                    }
                });

                const sortedUniqueAssignments = Array.from(uniqueAssignments.values()).sort((a, b) => a.person.localeCompare(b.person));

                if (sortedUniqueAssignments.length > 0) {
                    const h = document.createElement('h5');
                    h.textContent = 'Назначения на этот день:';
                    h.style.margin = '10px 0 5px 0';
                    h.style.fontWeight = 'bold';
                    h.style.color = '#00bfff';
                    body.appendChild(h);

                    sortedUniqueAssignments.forEach(a => {
                        const p = document.createElement('p');
                        const color = this.getColorFor(a.person);
                        p.style.backgroundColor = color;
                        p.style.color = this.isLightColor(color) ? '#333' : '#fff';
                        p.style.borderRadius = '7px';
                        p.style.padding = '6px 10px';
                        p.style.margin = '2px 0';
                        p.textContent = `${SERVICE.sanitizeInput(a.person)}${a.shift ? ' ('+SERVICE.sanitizeInput(a.shift)+')' : ''}`;
                        body.appendChild(p);
                    });
                } else {
                    body.innerHTML = '<p>На этот день нет назначений.</p>';
                }
                this.openModal('view');
            };
            
            VIEW.renderAssignmentModalList = function(calendarType) {
                const list = document.getElementById('assignmentsList');
                if (!list) return;
                
                const keyMap = { technician: 'techDuties', general: 'generalSchedule' };
                const assignments = STATE[keyMap[calendarType]][STATE.currentMonth][STATE.currentSelectedDay] || [];
                
                if (assignments.length === 0) {
                    list.innerHTML = 'Нет назначений.';
                    return;
                }
                list.innerHTML = assignments.map((a, i) => `
                    <div class="assignment-item">
                        <span>${SERVICE.sanitizeInput(a.person)} (${SERVICE.sanitizeInput(a.shift)})</span>
                        <button class="delete-assignment-btn" data-action="deleteAssignment" data-index="${i}">&times;</button>
                    </div>`).join('');
            };

            VIEW.openModal = function(type) {
                const overlay = this[`${type}ModalOverlay`];
                if (overlay) overlay.classList.add('show');
                document.querySelector(`.day-cell[data-day='${STATE.currentSelectedDay}']`)?.classList.add('selected-for-modal');
                if (type === 'edit') {
                    const closeBtn = overlay.querySelector('.modal-close');
                    if (closeBtn) closeBtn.style.display = '';
                }
            };

            VIEW.closeModal = function() {
                if (this.editModalOverlay) this.editModalOverlay.classList.remove('show');
                if (this.viewModalOverlay) this.viewModalOverlay.classList.remove('show');
                const prevSelected = document.querySelector('.day-cell.selected-for-modal');
                if (prevSelected) prevSelected.classList.remove('selected-for-modal');
                STATE.currentSelectedDay = null;
            };
            
            VIEW.showConfirmModal = function(message) {
                return new Promise(resolve => {
                    STATE.confirmModalResolve = resolve;
                    if (this.confirmModalMessage) this.confirmModalMessage.textContent = message;
                    if (this.confirmModalOverlay) this.confirmModalOverlay.classList.add('show');
                });
            };

            VIEW.closeConfirmModal = function(result) {
                if (this.confirmModalOverlay) this.confirmModalOverlay.classList.remove('show');
                if (STATE.confirmModalResolve) {
                    STATE.confirmModalResolve(result);
                    STATE.confirmModalResolve = null;
                }
            };

            VIEW.showSummaryModal = function(summaryText, monthYear) {
                if (this.summaryModalTitle) this.summaryModalTitle.textContent = `Сводка за ${SERVICE.sanitizeInput(monthYear)}`;
                if (this.summaryModalBody) this.summaryModalBody.innerHTML = `<pre style="white-space: pre-wrap; word-wrap: break-word;">${SERVICE.sanitizeInput(summaryText)}</pre>`;
                if (this.summaryModalOverlay) this.summaryModalOverlay.classList.add('show');
            };

            VIEW.closeSummaryModal = function() {
                if (this.summaryModalOverlay) this.summaryModalOverlay.classList.remove('show');
            };

            VIEW.showNotification = function(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);
                
                setTimeout(() => notification.classList.add('show'), 10);
                setTimeout(() => {
                    notification.classList.remove('show');
                    notification.addEventListener('transitionend', () => notification.remove());
                }, 3000);
            };
            
            VIEW.getColorFor = function(str) {
                if(!str) return '#ccc';
                if (STATE.colors[str]) return STATE.colors[str];
                let hash = 0;
                for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
                let color = '#';
                for (let i = 0; i < 3; i++) {
                    const value = (hash >> (i * 8)) & 0xFF;
                    color += ('00' + value.toString(16)).substr(-2);
                }
                return STATE.colors[str] = color;
            };

            VIEW.isLightColor = function(hex) {
                const r = parseInt(hex.substring(1, 3), 16);
                const g = parseInt(hex.substring(3, 5), 16);
                const b = parseInt(hex.substring(5, 7), 16);
                return (r * 299 + g * 587 + b * 114) / 1000 > 180;
            };

            const CONTROLLER = {
                init() {
                    document.body.addEventListener('click', this.globalClickListener.bind(this));
                    this.setupInputListeners(); // New call
                },

                globalClickListener(e) {
                    const target = e.target;
                    
                    const dayCell = target.closest('.day-cell:not(.empty)');
                    if (dayCell) {
                        const grid = dayCell.closest('.calendar-grid');
                        SERVICE.handleDayClick(parseInt(dayCell.dataset.day, 10), grid.dataset.calendarType);
                        return;
                    }

                    const tabButton = target.closest('.tab-button[data-tab]');
                    if (tabButton) {
                        SERVICE.switchTab(tabButton.dataset.tab);
                        return;
                    }

                    const actionTarget = target.closest('[data-action]');
                    if (actionTarget) {
                        const { action, name, index, personIdToDelete } = actionTarget.dataset;
                        
                        switch (action) {
                            case 'toggleEditMode': SERVICE.toggleEditMode(); break;
                            case 'save': SERVICE.saveData(); break;
                            case 'clear': SERVICE.clearMonth(); break;
                            case 'cancel': SERVICE.cancelChanges(); break;
                            case 'toggleSection': document.getElementById(actionTarget.dataset.target)?.classList.toggle('hidden-section'); break;
                            case 'addPerson': SERVICE.addPerson(VIEW.newOfficerNameInput.value, VIEW.newOfficerTelegramIdInput.value); break;
                            case 'deletePerson': SERVICE.deletePerson(personIdToDelete); break;
                            case 'closeModal': VIEW.closeModal(); break;
                            case 'closeConfirmModal': VIEW.closeConfirmModal(false); break;
                            case 'closeSummaryModal': VIEW.closeSummaryModal(); break;
                            case 'selectDuty': SERVICE.assignDuty(name); break;
                            case 'addAssignment': {
                                const modalBody = target.closest('.modal-body');
                                const person = modalBody.querySelector('#personSelect').value;
                                const shift = modalBody.querySelector('#shiftSelect').value;
                                SERVICE.addAssignment(person, shift, modalBody.dataset.calendarType);
                                break;
                            }
                            case 'deleteAssignment': {
                                 const modalBody = target.closest('.modal-body');
                                 SERVICE.deleteAssignment(parseInt(index, 10), modalBody.dataset.calendarType);
                                 break;
                            }
                            case 'generateMonthSummary': SERVICE.generateMonthSummary(); break;
                        }
                    }
                    
                    if(target.matches('#confirmModalConfirmBtn')) VIEW.closeConfirmModal(true);
                    if(target.matches('#confirmModalCancelBtn')) VIEW.closeConfirmModal(false);
                },

                setupInputListeners() { // New function
                    const idInput = VIEW.newOfficerTelegramIdInput; // Use VIEW's stored reference
                    const addBtn = VIEW.addPersonBtn; // Use VIEW's stored reference

                    if (idInput && addBtn) {
                        idInput.addEventListener('input', () => {
                            idInput.value = idInput.value.replace(/\D/g, '');
                            // Disable add button if ID is invalid or user is not admin
                            if (!/^\d+$/.test(idInput.value) || idInput.value.length < 6 || STATE.userRole !== 'admin') {
                                idInput.style.borderColor = '#dc2626';
                                addBtn.disabled = true;
                            } else {
                                idInput.style.borderColor = '';
                                addBtn.disabled = false;
                            }
                        });
                        // Initial check for button state based on role (even if input is empty)
                        addBtn.disabled = STATE.userRole === 'admin' ? false : true; // Only admin can add
                        addBtn.title = STATE.userRole === 'admin' ? "" : "Только администратор может добавлять сотрудников";
                    }
                },
            };

            document.addEventListener('DOMContentLoaded', () => {
                SERVICE.init();
            });

            SERVICE.changeYear = function(newYear) {
                STATE.year = parseInt(newYear, 10);
                SERVICE.setupFirestoreListeners();
                VIEW.renderAll();
                VIEW.renderMonthSelector();
            };
        })();
    </script>
    <style>
        /* Общие стили */
        :root {
            --bg-main: #1a1a2e;
            --bg-container: #0f3460;
            --bg-element: #2d3748;
            --bg-element-hover: #4a5568;
            --bg-accent: #533483;
            --bg-weekend: #3d2a45;
            --text-main: #e0e6ed;
            --text-light: #ffffff;
            --border-main: #4a5568;
            --border-accent: #00bfff;
            --btn-green: #059669;
            --btn-green-hover: #047857;
            --btn-red: #dc2626;
            --btn-red-hover: #b91c1c;
            --btn-blue: #2563eb;
            --btn-blue-hover: #1d4ed8;
            --shadow-main: rgba(0,0,0,0.3);
            --shadow-accent: rgba(0, 191, 255, 0.5);

            /* Font sizes for responsiveness */
            --font-size-xs: 8px;
            --font-size-sm: 10px;
            --font-size-md: 12px;
            --font-size-lg: 14px;
            --font-size-xl: 16px;
            --font-size-xxl: 20px; /* For day-number on larger screens */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-main);
            min-height: 100vh;
            padding: 10px;
            color: var(--text-main);
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            background: var(--bg-container);
            border-radius: 20px;
            box-shadow: 0 20px 40px var(--shadow-main);
            overflow: hidden;
        }
        .unauthorized {
            text-align: center;
            padding: 50px;
        }

        /* Заголовок */
        .header {
            background: linear-gradient(135deg, var(--bg-accent) 0%, var(--bg-container) 100%);
            color: var(--text-light);
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            text-align: center;
        }
        .user-info {
            font-size: 0.9em;
            opacity: 0.9;
        }
        .user-info span {
            font-weight: bold;
        }

        .header h1 {
            font-size: 2em;
            font-weight: 300;
        }

        .month-year-selectors {
            background: rgba(255,255,255,0.04);
            border-radius: 12px;
            padding: 4px 8px;
            display: flex;
            gap: 8px;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .custom-dropdown {
            position: relative;
            min-width: 90px;
            max-width: 140px;
            font-size: 15px;
            user-select: none;
        }
        .dropdown-selected {
            background: var(--bg-element);
            border: 2px solid var(--border-main);
            border-radius: 10px;
            padding: 8px 32px 8px 12px;
            color: var(--text-light);
            cursor: pointer;
            position: relative;
            transition: border 0.2s;
            min-width: 90px;
            max-width: 140px;
            display: flex;
            align-items: center;
        }
        .dropdown-selected:after {
            content: '';
            display: block;
            position: absolute;
            right: 12px;
            top: 50%;
            width: 16px;
            height: 16px;
            pointer-events: none;
            transform: translateY(-50%);
            background-image: url('data:image/svg+xml;utf8,<svg fill="%23cccccc" height="16" viewBox="0 0 20 20" width="16" xmlns="http://www.w3.org/2000/svg"><path d="M7.293 7.293a1 1 0 011.414 0L10 8.586l1.293-1.293a1 1 0 111.414 1.414l-2 2a1 1 0 01-1.414 0l-2-2a1 1 0 010-1.414z"/></svg>');
            background-size: 16px 16px;
            background-repeat: no-repeat;
        }
        .dropdown-list {
            display: none;
            position: absolute;
            left: 0;
            top: 110%;
            z-index: 100;
            background: var(--bg-element);
            border: 2px solid var(--border-main);
            border-radius: 10px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.25);
            min-width: 100%;
            max-height: 220px;
            overflow-y: auto;
            padding: 4px 0;
        }
        .dropdown-list.show {
            display: block;
            animation: fadeIn 0.15s;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .dropdown-item {
            padding: 8px 18px 8px 18px;
            color: var(--text-light);
            cursor: pointer;
            font-size: 15px;
            border: none;
            background: none;
            transition: background 0.15s, color 0.15s;
        }
        .dropdown-item.selected {
            background: var(--bg-accent);
            color: #fff;
            font-weight: bold;
        }
        .dropdown-item:hover {
            background: var(--bg-weekend);
            color: #fff;
        }
        @media (max-width: 480px) {
            .custom-dropdown, .dropdown-selected {
                font-size: var(--font-size-md);
                min-width: 70px;
                max-width: 90px;
            }
            .dropdown-item {
                font-size: var(--font-size-md);
                padding: 7px 10px 7px 10px;
            }
        }

        /* Кнопки */
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 12px;
            font-size: var(--font-size-lg);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            min-height: 44px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            color: var(--text-light);
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .btn--save { background: var(--btn-green); }
        .btn--save:hover:not(:disabled) { background: var(--btn-green-hover); }
        .btn--clear { background: var(--btn-red); }
        .btn--clear:hover:not(:disabled) { background: var(--btn-red-hover); }
        .btn--cancel { background: var(--bg-element-hover); }
        .btn--cancel:hover:not(:disabled) { background: var(--bg-element); }
        .btn--edit-mode, .btn--blue { background: var(--btn-blue); }
        .btn--edit-mode:hover:not(:disabled), .btn--blue:hover:not(:disabled) { background: var(--btn-blue-hover); }
        .btn--toggle {
            background: var(--bg-element);
            border: 1px solid var(--border-main);
            box-shadow: none;
            padding: 8px 15px;
        }
        .btn--toggle:hover:not(:disabled) {
            background: var(--bg-element-hover);
            transform: none;
        }

        /* Основное содержимое */
        .main-content {
            padding: 20px;
        }

        .section-container {
            background: var(--bg-main);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid var(--bg-element);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .section-container h3 {
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        /* Навигация */
        .tab-navigation {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
            flex-wrap: wrap;
        }
        .tab-button {
            background: var(--bg-element-hover);
            padding: 10px 20px;
            border-radius: 10px;
            min-width: 150px;
            text-align: center;
        }
        .tab-button.active {
            background: linear-gradient(135deg, var(--bg-accent) 0%, var(--bg-container) 100%);
            border: 2px solid var(--border-accent);
            box-shadow: 0 0 15px var(--shadow-accent);
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* Сетка календаря */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            background: var(--bg-element);
            border-radius: 10px;
            overflow: hidden;
        }
        .day-header {
            background: var(--bg-element-hover);
            padding: 12px 8px;
            text-align: center;
            font-weight: 600;
            font-size: var(--font-size-md);
        }
        .day-cell {
            background: var(--bg-element);
            /* Removed min-height here to allow dynamic sizing */
            padding: 8px 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            gap: 4px;
            border: 1px solid var(--border-main);
            border-radius: 8px;
        }
        .day-cell:hover:not(.empty) {
            background: var(--bg-element-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px var(--shadow-main);
        }
        .day-cell.weekend { background: var(--bg-weekend); }
        .day-cell.weekend:hover:not(:disabled) { background: #553c5d; }
        .day-cell.current-day {
            border: 2px solid var(--border-accent);
            box-shadow: 0 0 15px var(--shadow-accent);
        }
        .day-cell.selected-for-modal {
            border: 3px solid var(--border-accent);
            box-shadow: 0 0 25px rgba(0, 191, 255, 0.9);
            transform: scale(1.03);
        }
        .day-number {
            font-weight: 700; /* Bolder */
            font-size: var(--font-size-xxl); /* Larger */
            color: var(--text-light); /* Brighter color */
            text-shadow: 0 0 5px rgba(0, 191, 255, 0.2); /* Subtle glow */
        }
        .day-entries-container {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: center;
            align-items: center; /* Изменено с flex-start на center */
            flex-grow: 1;
            overflow: hidden;
        }
        .avatar-initials {
            border-radius: 50%; /* Make it a circle */
            border: 2px solid rgba(255, 255, 255, 0.3); /* Interesting border */
            box-shadow: 0 0 8px rgba(0, 191, 255, 0.4); /* Glowing effect */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin: 2px 0;
            line-height: 1.1;
            text-align: center;
            transition: all 0.2s ease-in-out; /* Smooth transitions for size changes */
            flex-shrink: 0; /* Prevent shrinking */
        }
        .avatar-letters {
            font-weight: bold;
            line-height: 1;
        }
        .avatar-shift {
            font-weight: 500;
            opacity: 0.85;
            margin-top: 2px;
            line-height: 1;
        }

        /* Specific avatar sizes based on number of assignments */
        .avatar-single {
            width: clamp(35px, 10vw, 60px);
            height: clamp(35px, 10vw, 60px);
        }
        .avatar-single .avatar-letters {
            font-size: clamp(1em, 2.5vw, 2em);
        }
        .avatar-single .avatar-shift {
            font-size: clamp(0.5em, 1.5vw, 0.8em);
        }

        .avatar-two {
            width: clamp(25px, 7vw, 45px);
            height: clamp(25px, 7vw, 45px);
        }
        .avatar-two .avatar-letters {
            font-size: clamp(0.8em, 1.8vw, 1.4em);
        }
        .avatar-two .avatar-shift {
            font-size: clamp(0.3em, 1vw, 0.6em);
        }

        .avatar-multiple { /* For 3 or more */
            width: clamp(18px, 5vw, 36px);
            height: clamp(18px, 5vw, 36px);
        }
        .avatar-multiple .avatar-letters {
            font-size: clamp(0.6em, 1.2vw, 1em);
        }
        .avatar-multiple .avatar-shift {
            font-size: clamp(0.2em, 0.8vw, 0.5em);
        }
        .avatar-empty {
            width: 100%;
            height: 100%;
            background-color: transparent !important;
            box-shadow: none !important;
            border: none !important;
            cursor: default;
        }

        /* Styles for unauthorized/error messages */
        .unauthorized {
            background-color: var(--bg-container);
            color: var(--text-main);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            max-width: 600px;
            margin: 50px auto;
        }

        .unauthorized h1 {
            color: var(--btn-red);
            font-size: 2.2em;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .unauthorized p {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .unauthorized a {
            color: var(--border-accent);
            text-decoration: none;
            font-weight: bold;
        }

        .unauthorized a:hover {
            text-decoration: underline;
        }

        .unauthorized strong {
            color: var(--text-light);
        }
    </style>
</head>
<body>
    <div id="loadingIndicator" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; color: white; font-size: 1.5em; z-index: 9999;">Загрузка...</div>
    <div class="container" id="appContainer">
        <!-- App content will be rendered here by JavaScript -->
    </div>

    <!-- MODALS (kept outside the main container for positioning) -->
    <!-- Universal Modal for Editing -->
    <div class="modal-overlay" id="editModalOverlay">
        <div class="modal" id="editModal">
            <div class="modal-header">
                <h4 id="editModalTitle"></h4>
                <button class="modal-close" data-action="closeModal">&times;</button>
            </div>
            <div class="modal-body" id="editModalBody"></div>
        </div>
    </div>
    
    <!-- Enlarged Day View Modal -->
    <div class="modal-overlay" id="viewModalOverlay" data-action="closeModal">
        <div class="modal">
            <div class="modal-header">
                <h4 id="viewModalTitle">Просмотр дня</h4>
                <button class="modal-close" data-action="closeModal">&times;</button>
            </div>
            <div class="modal-body enlarged-day-content" id="viewModalBody"></div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal-overlay confirm-modal" id="confirmModalOverlay">
        <div class="modal">
            <div class="modal-header">
                <h4>Подтверждение</h4>
                <button class="modal-close" data-action="closeConfirmModal">&times;</button>
            </div>
            <div class="modal-body" id="confirmModalMessage"></div>
            <div class="modal-footer">
                <button class="btn btn--save" id="confirmModalConfirmBtn">Да</button>
                <button class="btn btn--cancel" id="confirmModalCancelBtn">Отмена</button>
            </div>
        </div>
    </div>

    <!-- New Summary Modal -->
    <div class="modal-overlay" id="summaryModalOverlay">
        <div class="modal">
            <div class="modal-header">
                <h4 id="summaryModalTitle">Сводка за месяц</h4>
                <button class="modal-close" data-action="closeSummaryModal">&times;</button>
            </div>
            <div class="modal-body" id="summaryModalBody" style="max-height: 70vh;"></div>
        </div>
    </div>
</body>
</html>

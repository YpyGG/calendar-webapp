<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Календарь для Telegram</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Оборачиваем весь код в IIFE для создания замкнутой области видимости
        (function() {
            'use strict';

            /**
             * CONFIG: Константы и конфигурация приложения
             */
            const CONFIG = {
                // Default Telegram ID for the admin (user's ID)
                DEFAULT_ADMIN_ID: "670669284", // Replace with your actual Telegram ID
                DEFAULT_ADMIN_NAME: "Администратор", // Placeholder name for the default admin if not provided by Telegram
                ROLE_NAMES: {
                    'admin': 'Администратор',
                    'boss': 'Начальник',
                    'worker': 'Работяга',
                    'guest': 'Гость'
                },
                DOM_SELECTORS: {
                    container: '#appContainer',
                    monthSelector: '#monthSelector',
                    newOfficerName: '#newOfficerName',
                    newOfficerTelegramId: '#newOfficerTelegramId', // New selector
                    dutyCalendarGrid: '#dutyCalendarGrid',
                    technicianCalendarGrid: '#technicianCalendarGrid',
                    generalCalendarGrid: '#generalCalendarGrid',
                    statsList: '#statsList',
                    currentOfficersList: '#currentOfficersList',
                    actionButtons: '#actionButtons',
                    tabNavigation: '#tabNavigation',
                    loadingIndicator: '#loadingIndicator', // New loading indicator
                    editModal: {
                        overlay: '#editModalOverlay',
                        title: '#editModalTitle',
                        body: '#editModalBody',
                    },
                    viewModal: {
                        overlay: '#viewModalOverlay',
                        title: '#viewModalTitle',
                        body: '#viewModalBody',
                    },
                    confirmModal: {
                        overlay: '#confirmModalOverlay',
                        message: '#confirmModalMessage',
                        confirmBtn: '#confirmModalConfirmBtn',
                        cancelBtn: '#confirmModalCancelBtn',
                    },
                    summaryModal: { // New modal for summary
                        overlay: '#summaryModalOverlay',
                        title: '#summaryModalTitle',
                        body: '#summaryModalBody',
                    },
                    firebaseSettings: { // New selectors for Firebase settings
                        section: '#firebaseSettingsSection',
                        // Removed configInput, tokenInput, saveBtn as they are no longer needed for manual input
                        receivedConfig: '#receivedFirebaseConfig',
                        receivedToken: '#receivedFirebaseToken',
                    }
                },
                STORAGE_KEYS: { // These are now Firestore collection/document names
                    USERS_COLLECTION: 'users',
                    MONTHS_COLLECTION: 'months',
                    // Removed LOCAL_FIREBASE_CONFIG and LOCAL_FIREBASE_TOKEN as config is hardcoded
                },
                // Removed "8pc" from SHIFT_TYPES
                SHIFT_TYPES: ["8", "ДС", "День караул", "Ночь караул", "Отсыпной", "Выходной", "Отпуск", "Больничный"],
                NO_DUTY_LABEL: "Нет дежурства",
                NAME_REGEX: /^[А-ЯЁ][а-яё]+\s[А-ЯЁ]\.[А-ЯЁ]\.$/,
                INITIAL_DATA: {
                    // Initial officers and technicians lists are now used to populate `STATE.users` on first load
                    officers: ["Морозов В.А.", "Ребраков Т.В.", "Костырин С.С.", "Бонадыков В.В.", "Бурлаков М.Ю.", "Артемьев А.М.", "Мефед И.С."],
                    technicians: ["Ребраков Т.В.", "Морозов В.А.", "Кузавлев П.С.", "Лебедев А.В.", "Денщиков А.А."],
                    julyDuties: { "1": "Ребраков Т.В.", "2": "Костырин С.С.", "3": "Морозов В.А.", "4": "Ребраков Т.В.", "6": "Костырин С.С.", "7": "Костырин С.С.", "8": "Ребраков Т.В.", "9": "Морозов В.А.", "10": "Морозов В.А.", "11": "Костырин С.С.", "12": "Ребраков Т.В.", "13": "Морозов В.А.", "14": "Костырин С.С.", "15": "Ребраков Т.В.", "16": "Морозов В.А.", "17": "Ребраков Т.В.", "18": "Ребраков Т.В.", "19": "Костырин С.С.", "20": "Морозов В.А.", "21": "Костырин С.С.", "22": "Ребраков Т.В.", "23": "Морозов В.А.", "24": "Костырин С.С.", "25": "Ребраков Т.В.", "26": "Морозов В.А.", "27": "Костырин С.С.", "28": "Костырин С.С.", "29": "Морозов В.А.", "30": "Костырин С.С.", "31": "Ребраков Т.В." },
                    // Initial technician duties (if needed, otherwise will be empty)
                    technicianDuties: {
                        "1": [{person: "Кузавлев П.С.", shift: "8"}],
                        "2": [{person: "Лебедев А.В.", shift: "8"}],
                        "3": [{person: "Денщиков А.А.", shift: "8"}],
                    },
                    // Initial general schedule data (if needed, otherwise will be empty)
                    generalScheduleData: {
                        "1": [{ person: "Ребраков Т.В.", shift: "8" }, { person: "Кузавлев П.С.", shift: "ДС" }],
                    }
                },
                // Hardcoded Firebase configuration provided by the user
                FIREBASE_CONFIG: {
                    apiKey: "AIzaSyBrfimxAJC-fN4aThvXH_B4jMWDA4pwysk",
                    authDomain: "ik2grafik.firebaseapp.com",
                    projectId: "ik2grafik",
                    storageBucket: "ik2grafik.firebasestorage.app",
                    messagingSenderId: "141207090372",
                    appId: "1:141207090372:web:b292ee339a23640027c591",
                    measurementId: "G-CSVDH3P8V1"
                }
            };

            /**
             * STATE: Единственный источник правды для состояния приложения.
             */
            const STATE = {
                appId: typeof __app_id !== 'undefined' ? __app_id : 'default-app-id',
                db: null,
                auth: null,
                telegramUser: null,
                currentUserId: null, // Firebase UID
                userRole: 'guest', // Determined after loading users data
                year: new Date().getFullYear(),
                currentMonth: new Date().getMonth(),
                activeTab: 'duty',
                isEditMode: false,
                hasUnsavedChanges: false,
                duties: {},
                techDuties: {},
                generalSchedule: {},
                users: {}, // { "telegramId": { name: "Фамилия И.О.", role: "admin" } }
                officers: [], // Derived from users and initial data
                technicians: [], // Derived from users and initial data
                colors: {},
                confirmModalResolve: null,
                currentSelectedDay: null,
                unsubscribeListeners: [], // To store Firestore unsubscribe functions
                // manualFirebaseConfig and manualFirebaseToken are no longer needed
            };

            /**
             * SERVICE: "Мозг" приложения. Управляет состоянием и бизнес-логикой.
             */
            const SERVICE = {
                async init() {
                    VIEW.showLoadingIndicator();
                    this.initTelegram(); // Initialize Telegram Web App first to get user info
                    
                    await this.initFirebase(); // Initialize Firebase
                    
                    // Log Firebase initialization status
                    console.log("Firebase initialized. STATE.db:", STATE.db ? "OK" : "NULL", "STATE.auth:", STATE.auth ? "OK" : "NULL");

                    // Only proceed with authentication if Firebase Auth is initialized
                    if (!STATE.auth) {
                        console.error("Firebase Auth is not initialized. Cannot proceed with authentication.");
                        VIEW.showNotification("Ошибка: Служба аутентификации Firebase недоступна. Проверьте конфигурацию.", "error");
                        VIEW.renderUnauthorized('auth_failed'); // Render specific unauthorized message
                        VIEW.hideLoadingIndicator();
                        return;
                    }

                    await this.authenticateFirebase();

                    if (!STATE.currentUserId) {
                        console.error("Authentication failed, currentUserId is null. Rendering unauthorized.");
                        VIEW.renderUnauthorized('auth_failed'); // Render specific unauthorized message
                        VIEW.hideLoadingIndicator();
                        return;
                    }

                    await this.loadUsersFromFirestore(); // Load global user data (and add current user as guest if new)
                    this.determineUserRole(); // Determine role after users are loaded
                    console.log("User role after determination:", STATE.userRole); // Added for debugging
                    
                    if (STATE.userRole === 'guest') {
                        console.error("User role determined as 'guest'. Rendering unauthorized.");
                        VIEW.renderUnauthorized('guest_role'); // Render specific unauthorized message
                        VIEW.hideLoadingIndicator();
                        return;
                    }

                    // Render the main app shell and initialize DOM element references
                    VIEW.renderAppShell();
                    VIEW.initAppElements(); // Get references to all dynamically created elements
                    
                    this.setupFirestoreListeners(); // Set up real-time listeners for calendar data
                    CONTROLLER.init();
                    VIEW.renderAll(); // Render initial data into the app shell
                    VIEW.hideLoadingIndicator();
                    console.log("Application Initialized for user:", STATE.telegramUser, "with role:", STATE.userRole, "Firebase UID:", STATE.currentUserId);
                },

                async initFirebase() {
                    try {
                        const firebaseConfig = CONFIG.FIREBASE_CONFIG; // Use hardcoded config

                        // Add a check for valid config
                        if (!firebaseConfig || Object.keys(firebaseConfig).length === 0 || !firebaseConfig.apiKey || !firebaseConfig.projectId) {
                            console.error("Firebase config is missing or invalid. Config:", firebaseConfig);
                            VIEW.showNotification("Ошибка: Неверная конфигурация Firebase. Убедитесь, что Firebase настроен правильно.", "error");
                            STATE.db = null; // Ensure state is consistent
                            STATE.auth = null; // Ensure state is consistent
                            return; // Stop initialization if config is bad
                        }
                        const app = initializeApp(firebaseConfig);
                        console.log("Firebase App initialized:", app); // Log the app instance
                        STATE.db = getFirestore(app);
                        STATE.auth = getAuth(app);
                        console.log("Firebase Auth instance:", STATE.auth); // Log the auth instance
                        console.log("Firebase initialized successfully from hardcoded config. STATE.db:", STATE.db ? "OK" : "NULL", "STATE.auth:", STATE.auth ? "OK" : "NULL");
                    } catch (e) {
                        console.error("Error initializing Firebase:", e);
                        VIEW.showNotification("Ошибка инициализации Firebase. Попробуйте позже.", "error");
                        STATE.db = null; // Ensure state is consistent
                        STATE.auth = null; // Ensure state is consistent
                    }
                },

                async authenticateFirebase() {
                    if (!STATE.auth) {
                        console.error("Firebase Auth is not initialized. Cannot authenticate.");
                        VIEW.showNotification("Ошибка: Служба аутентификации Firebase недоступна. Проверьте конфигурацию.", "error");
                        STATE.currentUserId = null;
                        return; // Exit if auth is not ready
                    }
                    try {
                        console.log("Attempting Firebase anonymous authentication...");
                        // Always sign in anonymously to avoid custom token issues
                        const userCredential = await signInAnonymously(STATE.auth);
                        STATE.currentUserId = userCredential.user.uid;
                        console.log("Signed in anonymously. Firebase UID:", STATE.currentUserId);

                    } catch (error) {
                        console.error("Error during Firebase authentication:", error);
                        // Updated notification message to reflect anonymous sign-in attempt
                        VIEW.showNotification("Ошибка аутентификации. Убедитесь, что Firebase Authentication включен для вашего проекта 'ik2grafik' в консоли Firebase (метод 'Anonymous').", "error");
                        STATE.currentUserId = null;
                    }
                },

                initTelegram() {
                    const tg = window.Telegram.WebApp;
                    tg.ready();
                    STATE.telegramUser = tg.initDataUnsafe.user;
                    // Для тестирования в браузере, если Telegram WebApp не доступен
                    if (!STATE.telegramUser) {
                        console.warn("Telegram WebApp user data not available, using fallback admin ID for testing.");
                        STATE.telegramUser = { id: parseInt(CONFIG.DEFAULT_ADMIN_ID), first_name: 'Тестовый', username: 'test_admin_user' };
                    }
                    tg.expand();
                },

                // --- Управление данными ---
                async loadUsersFromFirestore() {
                    if (!STATE.db) {
                        console.error("Firestore DB is not initialized. Cannot load users.");
                        return;
                    }
                    const usersRef = collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.USERS_COLLECTION}`);
                    try {
                        const querySnapshot = await getDocs(usersRef);
                        STATE.users = {};
                        querySnapshot.forEach(doc => {
                            STATE.users[doc.id] = doc.data();
                        });

                        const currentTelegramId = STATE.telegramUser.id.toString();
                        const telegramUserName = `${STATE.telegramUser.first_name} ${STATE.telegramUser.last_name || ''}`.trim();

                        // Ensure default admin exists and is correct
                        if (!STATE.users[CONFIG.DEFAULT_ADMIN_ID]) {
                            STATE.users[CONFIG.DEFAULT_ADMIN_ID] = {
                                name: CONFIG.DEFAULT_ADMIN_NAME,
                                role: 'admin'
                            };
                            await setDoc(doc(usersRef, CONFIG.DEFAULT_ADMIN_ID), STATE.users[CONFIG.DEFAULT_ADMIN_ID]);
                        } else if (STATE.users[CONFIG.DEFAULT_ADMIN_ID].role !== 'admin') {
                            // Ensure the default admin ID always has the admin role
                            STATE.users[CONFIG.DEFAULT_ADMIN_ID].role = 'admin';
                            await updateDoc(doc(usersRef, CONFIG.DEFAULT_ADMIN_ID), { role: 'admin' });
                        }

                        // Add current Telegram user as guest if they are not in Firestore and not the default admin
                        if (!STATE.users[currentTelegramId] && currentTelegramId !== CONFIG.DEFAULT_ADMIN_ID) {
                            STATE.users[currentTelegramId] = {
                                name: telegramUserName || `Пользователь ${currentTelegramId}`,
                                role: 'guest'
                            };
                            await setDoc(doc(usersRef, currentTelegramId), STATE.users[currentTelegramId]);
                        } else if (STATE.users[currentTelegramId] && STATE.users[currentTelegramId].name !== telegramUserName) {
                             // Update current user's name if it changed in Telegram
                            await updateDoc(doc(usersRef, currentTelegramId), { name: telegramUserName });
                            STATE.users[currentTelegramId].name = telegramUserName; // Update local state immediately
                        }

                        // Add initial officers/technicians as 'worker' if they are not already in Firestore
                        const allInitialPeople = [...new Set([...CONFIG.INITIAL_DATA.officers, ...CONFIG.INITIAL_DATA.technicians])];
                        for (const name of allInitialPeople) {
                            const existingUser = Object.values(STATE.users).find(u => u.name === name);
                            if (!existingUser) {
                                const placeholderId = `_ph_${name.replace(/\W/g, '')}_${Date.now()}`;
                                STATE.users[placeholderId] = { name: name, role: 'worker' };
                                await setDoc(doc(usersRef, placeholderId), STATE.users[placeholderId]);
                            }
                        }

                    } catch (e) {
                        console.error("Error loading users from Firestore:", e);
                        VIEW.showNotification("Ошибка загрузки данных пользователей.", "error");
                    }
                },

                determineUserRole() {
                    const currentTelegramId = STATE.telegramUser.id.toString();
                    if (currentTelegramId === CONFIG.DEFAULT_ADMIN_ID) {
                        STATE.userRole = 'admin'; // Force admin role for the default admin ID
                    } else if (STATE.users[currentTelegramId]) {
                        STATE.userRole = STATE.users[currentTelegramId].role;
                    } else {
                        STATE.userRole = 'guest';
                    }

                    // Populate officers and technicians lists from STATE.users
                    STATE.officers = Object.values(STATE.users)
                                        .filter(u => CONFIG.INITIAL_DATA.officers.includes(u.name) || u.role === 'admin' || u.role === 'boss')
                                        .map(u => u.name);
                    STATE.technicians = Object.values(STATE.users)
                                        .filter(u => CONFIG.INITIAL_DATA.technicians.includes(u.name) || u.role === 'worker' || u.role === 'boss' || u.role === 'admin')
                                        .map(u => u.name);
                    STATE.officers = [...new Set(STATE.officers)].sort();
                    STATE.technicians = [...new Set(STATE.technicians)].sort();
                },

                setupFirestoreListeners() {
                    // Unsubscribe previous listeners to prevent memory leaks
                    STATE.unsubscribeListeners.forEach(unsubscribe => unsubscribe());
                    STATE.unsubscribeListeners = [];

                    if (!STATE.db) {
                        console.error("Firestore DB is not initialized. Cannot set up listeners.");
                        return;
                    }

                    // Listener for global users data
                    const usersRef = collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.USERS_COLLECTION}`);
                    STATE.unsubscribeListeners.push(onSnapshot(usersRef, (snapshot) => {
                        snapshot.docChanges().forEach(change => {
                            STATE.users[change.doc.id] = change.doc.data();
                        });
                        this.determineUserRole(); // Re-determine role if users data changes
                        VIEW.renderManagementList(); // Re-render management list
                        VIEW.renderUserInfo(); // Update user info display
                    }, (error) => console.error("Error listening to users:", error)));

                    // Listener for current month's calendar data
                    const monthDocRef = doc(collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.MONTHS_COLLECTION}`), `${STATE.year}_${STATE.currentMonth}`);
                    STATE.unsubscribeListeners.push(onSnapshot(monthDocRef, (docSnapshot) => {
                        if (docSnapshot.exists()) {
                            const data = docSnapshot.data();
                            STATE.duties[STATE.currentMonth] = data.duties || {};
                            STATE.techDuties[STATE.currentMonth] = data.techDuties || {};
                            STATE.generalSchedule[STATE.currentMonth] = data.generalSchedule || {};
                            STATE.colors = data.colors || {};
                        } else {
                            STATE.duties[STATE.currentMonth] = {};
                            STATE.techDuties[STATE.currentMonth] = {};
                            STATE.generalSchedule[STATE.currentMonth] = {};
                            STATE.colors = {};
                            // Initialize with default July data if current month is July and document doesn't exist
                            if (STATE.currentMonth === 6) {
                                STATE.duties[6] = { ...CONFIG.INITIAL_DATA.julyDuties };
                                STATE.techDuties[6] = JSON.parse(JSON.stringify(CONFIG.INITIAL_DATA.technicianDuties));
                                STATE.generalSchedule[6] = JSON.parse(JSON.stringify(CONFIG.INITIAL_DATA.generalScheduleData));
                                this.saveData(); // Save initial data to Firestore
                            }
                        }
                        STATE.hasUnsavedChanges = false; // Reset on data refresh from Firestore
                        VIEW.renderAll();
                    }, (error) => console.error("Error listening to month data:", error)));
                },

                async saveData() {
                    if (!(STATE.userRole === 'admin' || STATE.userRole === 'boss')) {
                        VIEW.showNotification('У вас нет прав для сохранения изменений.', 'error');
                        return;
                    }
                    if (!STATE.db) {
                        VIEW.showNotification('База данных не инициализирована. Невозможно сохранить данные.', 'error');
                        return;
                    }

                    VIEW.showLoadingIndicator();
                    const monthDocRef = doc(collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.MONTHS_COLLECTION}`), `${STATE.year}_${STATE.currentMonth}`);
                    try {
                        await setDoc(monthDocRef, {
                            duties: STATE.duties[STATE.currentMonth],
                            techDuties: STATE.techDuties[STATE.currentMonth],
                            generalSchedule: STATE.generalSchedule[STATE.currentMonth],
                            colors: STATE.colors
                        }, { merge: true }); // Use merge to avoid overwriting other fields if they exist
                        
                        STATE.hasUnsavedChanges = false;
                        VIEW.showNotification('Изменения успешно сохранены!', 'success');
                    } catch (e) {
                        console.error("Error saving data to Firestore", e);
                        VIEW.showNotification('Ошибка сохранения данных', 'error');
                    } finally {
                        VIEW.hideLoadingIndicator();
                    }
                },

                // --- Управление UI ---
                async changeMonth(newMonth) {
                    if (STATE.hasUnsavedChanges) {
                        const confirmed = await VIEW.showConfirmModal('У вас есть несохраненные изменения. Вы уверены, что хотите продолжить без сохранения?');
                        if (!confirmed) {
                            VIEW.monthSelector.value = STATE.currentMonth;
                            return;
                        }
                    }
                    STATE.currentMonth = parseInt(newMonth, 10);
                    this.setupFirestoreListeners(); // Re-setup listener for new month
                    VIEW.renderAll();
                },

                async toggleEditMode() {
                    if (!(STATE.userRole === 'admin' || STATE.userRole === 'boss')) {
                        VIEW.showNotification('У вас нет прав для редактирования.', 'error');
                        return;
                    }
                    if (STATE.isEditMode && STATE.hasUnsavedChanges) {
                        const confirmed = await VIEW.showConfirmModal('У вас есть несохраненные изменения. Сохранить их перед выходом?');
                        if (confirmed) await this.saveData();
                        else this.setupFirestoreListeners(); // Revert to Firestore state
                    }
                    STATE.isEditMode = !STATE.isEditMode;
                    VIEW.showNotification(STATE.isEditMode ? 'Режим редактирования включен' : 'Режим просмотра', 'info');
                    VIEW.renderAll();
                },

                switchTab(tabName) {
                    STATE.activeTab = tabName;
                    VIEW.renderAll();
                },
                
                // --- Логика календаря ---
                handleDayClick(day, calendarType) {
                    STATE.currentSelectedDay = day;
                    if (STATE.isEditMode) {
                        if (calendarType === 'duty') VIEW.showDutyModal();
                        else VIEW.showAssignmentModal(calendarType);
                    } else {
                        VIEW.showEnlargedDayView(day);
                    }
                },

                assignDuty(person) {
                    const { currentMonth, currentSelectedDay: day } = STATE;
                    const dayKey = day.toString();
                    const assignment = { person, shift: 'ДС' };
                    const isPersonTechnician = STATE.technicians.includes(person);
                    const actionType = person === CONFIG.NO_DUTY_LABEL ? 'delete' : 'add';

                    if (actionType === 'delete') delete STATE.duties[currentMonth][dayKey];
                    else STATE.duties[currentMonth][dayKey] = person;

                    const update = (schedule, key, assign, add) => {
                        const current = schedule[currentMonth][key] || [];
                        let filtered = current.filter(a => !(a.person === assign.person && a.shift === assign.shift)); // Filter out exact match
                        if (add) {
                            // Also remove any existing 'ДС' assignment if adding a new one for an officer
                            if (assign.shift === 'ДС' && STATE.officers.includes(assign.person)) {
                                 filtered = filtered.filter(a => !(a.shift === 'ДС' && STATE.officers.includes(a.person)));
                            }
                            filtered.push(assign);
                            filtered.sort((a,b) => a.person.localeCompare(b.person));
                        }
                        if (filtered.length > 0) schedule[currentMonth][key] = filtered;
                        else delete schedule[currentMonth][key];
                    };
                    
                    update(STATE.generalSchedule, dayKey, assignment, actionType === 'add');
                    if (isPersonTechnician) update(STATE.techDuties, dayKey, assignment, actionType === 'add');

                    STATE.hasUnsavedChanges = true;
                    VIEW.closeModal();
                    VIEW.renderAll();
                },

                addAssignment(person, shift, calendarType) {
                    const { currentMonth, currentSelectedDay: day } = STATE;
                    const dayKey = day.toString();
                    const scheduleKey = calendarType === 'technician' ? 'techDuties' : 'generalSchedule';
                    
                    const assignments = STATE[scheduleKey][currentMonth][dayKey] || [];
                    const newAssignment = { person, shift };

                    if (assignments.some(a => a.person === person && a.shift === shift)) {
                        VIEW.showNotification('Такое назначение уже существует.', 'info');
                        return;
                    }
                    
                    // Logic for "ДС" shift in General Schedule
                    if (calendarType === 'general' && shift === "ДС") {
                        const existingDsIndex = assignments.findIndex(item => item.shift === "ДС" && STATE.officers.includes(item.person));
                        if (existingDsIndex !== -1) {
                            const existingDsPerson = assignments[existingDsIndex].person;
                            VIEW.showConfirmModal(`На этот день уже назначен дежурный (ДС): ${existingDsPerson}. Вы хотите заменить его на ${newAssignment.person}?`)
                                .then(confirmed => {
                                    if (confirmed) {
                                        // Remove old DS assignment from general schedule
                                        assignments.splice(existingDsIndex, 1);
                                        // Remove old DS assignment from duty schedule
                                        if (STATE.duties[currentMonth] && STATE.duties[currentMonth][dayKey] === existingDsPerson) {
                                            delete STATE.duties[currentMonth][dayKey];
                                        }
                                        // Remove old DS assignment from technician schedule if applicable
                                        if (STATE.technicians.includes(existingDsPerson)) {
                                            const techAssignments = STATE.techDuties[currentMonth][dayKey] || [];
                                            STATE.techDuties[currentMonth][dayKey] = techAssignments.filter(a => !(a.person === existingDsPerson && a.shift === "ДС"));
                                            if (STATE.techDuties[currentMonth][dayKey].length === 0) delete STATE.techDuties[currentMonth][dayKey];
                                        }
                                        // Add new assignment and sync
                                        assignments.push(newAssignment);
                                        assignments.sort((a, b) => a.person.localeCompare(b.person));
                                        this.syncSchedules('add', newAssignment, calendarType);
                                        STATE.hasUnsavedChanges = true;
                                        VIEW.renderAssignmentModalList(calendarType);
                                        VIEW.renderAll();
                                        VIEW.showNotification('Назначение добавлено и заменено!', 'success');
                                    } else {
                                        VIEW.showNotification('Замена отменена.', 'info');
                                    }
                                });
                            return; // Exit to wait for confirmation
                        }
                    }

                    assignments.push(newAssignment);
                    assignments.sort((a, b) => a.person.localeCompare(b.person));
                    STATE[scheduleKey][currentMonth][dayKey] = assignments;

                    this.syncSchedules('add', newAssignment, calendarType);

                    STATE.hasUnsavedChanges = true;
                    VIEW.renderAssignmentModalList(calendarType);
                    VIEW.renderAll(); 
                    VIEW.showNotification('Назначение добавлено!', 'success');
                },

                deleteAssignment(index, calendarType) {
                    const { currentMonth, currentSelectedDay: day } = STATE;
                    const dayKey = day.toString();
                    const scheduleKey = calendarType === 'technician' ? 'techDuties' : 'generalSchedule';
                    const assignments = STATE[scheduleKey][currentMonth][dayKey];

                    if (assignments && index >= 0 && index < assignments.length) {
                        const deletedAssignment = assignments.splice(index, 1)[0];
                        if (assignments.length === 0) {
                            delete STATE[scheduleKey][currentMonth][dayKey];
                        }
                        
                        this.syncSchedules('delete', deletedAssignment, calendarType);

                        STATE.hasUnsavedChanges = true;
                        VIEW.renderAssignmentModalList(calendarType);
                        VIEW.renderAll();
                        VIEW.showNotification('Назначение удалено!', 'info');
                    }
                },
                
                syncSchedules(actionType, assignment, sourceCalendar) {
                    const { person, shift } = assignment;
                    const { currentMonth, currentSelectedDay: day } = STATE;
                    const dayKey = day.toString();
                    
                    const isPersonOfficer = STATE.officers.includes(person);
                    const isPersonTechnician = STATE.technicians.includes(person);

                    const update = (schedule, key, assign, add) => {
                        const current = schedule[currentMonth][key] || [];
                        let filtered = current.filter(a => !(a.person === assign.person && a.shift === assign.shift));
                        if (add) {
                            filtered.push(assign);
                            filtered.sort((a,b) => a.person.localeCompare(b.person));
                        }
                        if (filtered.length > 0) schedule[currentMonth][key] = filtered;
                        else delete schedule[currentMonth][key];
                    };

                    if (sourceCalendar === 'technician') {
                        update(STATE.generalSchedule, dayKey, assignment, actionType === 'add');
                    } else if (sourceCalendar === 'general') {
                        if (shift === 'ДС' && isPersonOfficer) {
                            if (actionType === 'add') STATE.duties[currentMonth][dayKey] = person;
                            else if (STATE.duties[currentMonth][dayKey] === person) delete STATE.duties[currentMonth][dayKey];
                        }
                        // Engineers are technicians, so if "ДС" is assigned to an engineer, it should appear in tech schedule
                        if (isPersonTechnician && (shift === '8' || shift === 'ДС')) {
                            update(STATE.techDuties, dayKey, assignment, actionType === 'add');
                        }
                    }
                },

                // --- Управление персоналом и ролями ---
                async addPerson(name, telegramId = null) {
                    if (STATE.userRole !== 'admin') {
                        VIEW.showNotification('Только администратор может добавлять сотрудников.', 'error');
                        return;
                    }
                    if (!name || !CONFIG.NAME_REGEX.test(name)) {
                        VIEW.showNotification("Введите имя в формате 'Фамилия И.О.'", 'error');
                        return;
                    }
                    if (!STATE.db) {
                        VIEW.showNotification('База данных не инициализирована. Невозможно добавить сотрудника.', 'error');
                        return;
                    }

                    // Check if name already exists in STATE.users
                    const existingUserByName = Object.values(STATE.users).find(u => u.name === name);
                    if (existingUserByName) {
                        VIEW.showNotification('Сотрудник с таким именем уже существует.', 'info');
                        return;
                    }

                    let newId = telegramId ? telegramId.toString() : `_ph_${name.replace(/\W/g, '')}_${Date.now()}`;
                    
                    // Check if Telegram ID already exists
                    if (telegramId && STATE.users[telegramId.toString()]) {
                        VIEW.showNotification('Пользователь с таким Telegram ID уже существует.', 'info');
                        return;
                    }

                    const usersRef = collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.USERS_COLLECTION}`);
                    try {
                        await setDoc(doc(usersRef, newId), { name: name, role: 'worker' }); // Default to worker
                        VIEW.showNotification(`Сотрудник ${name} добавлен!`, 'success');
                        VIEW.newOfficerNameInput.value = '';
                        VIEW.newOfficerTelegramIdInput.value = ''; // Clear new ID input
                    } catch (e) {
                        console.error("Error adding person to Firestore:", e);
                        VIEW.showNotification("Ошибка добавления сотрудника.", "error");
                    }
                },

                async deletePerson(personIdToDelete) {
                    if (STATE.userRole !== 'admin') {
                        VIEW.showNotification('Только администратор может удалять сотрудников.', 'error');
                        return;
                    }
                    if (personIdToDelete === STATE.telegramUser.id.toString()) {
                        VIEW.showNotification('Вы не можете удалить себя.', 'error');
                        return;
                    }
                    if (!STATE.db) {
                        VIEW.showNotification('База данных не инициализирована. Невозможно удалить сотрудника.', 'error');
                        return;
                    }

                    const personName = STATE.users[personIdToDelete]?.name;
                    if (!personName) {
                        VIEW.showNotification('Сотрудник не найден.', 'error');
                        return;
                    }

                    const confirmed = await VIEW.showConfirmModal(`Вы уверены, что хотите удалить сотрудника "${personName}"? Все его дежурства и назначения будут стерты.`);
                    if (!confirmed) return;

                    const usersRef = collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.USERS_COLLECTION}`);
                    try {
                        await deleteDoc(doc(usersRef, personIdToDelete));

                        // Remove all duties/assignments for this person across all months and calendars
                        // This part will be handled by the onSnapshot listener for month data,
                        // as the data will be re-rendered when the month document updates.
                        // However, to ensure immediate consistency and prevent potential issues with stale data,
                        // we can explicitly clean up the local STATE data.
                        for (let month = 0; month < 12; month++) {
                            if (STATE.duties[month]) {
                                Object.keys(STATE.duties[month]).forEach(day => {
                                    if (STATE.duties[month][day] === personName) {
                                        delete STATE.duties[month][day];
                                    }
                                });
                            }
                            ['techDuties', 'generalSchedule'].forEach(key => {
                                if (STATE[key][month]) {
                                    Object.keys(STATE[key][month]).forEach(day => {
                                        if (Array.isArray(STATE[key][month][day])) {
                                            STATE[key][month][day] = STATE[key][month][day].filter(a => a.person !== personName);
                                            if (STATE[key][month][day].length === 0) {
                                                delete STATE[key][month][day];
                                            }
                                        }
                                    });
                                }
                            });
                        }
                        // Trigger a save to update the current month's data in Firestore after local cleanup
                        await this.saveData(); // This will update the current month's document in Firestore

                        VIEW.showNotification(`Сотрудник "${personName}" удален.`, 'info');
                    } catch (e) {
                        console.error("Error deleting person from Firestore:", e);
                        VIEW.showNotification("Ошибка удаления сотрудника.", "error");
                    }
                },

                async changePersonRole(personId, newRole) {
                    if (STATE.userRole !== 'admin') {
                        VIEW.showNotification('Только администратор может менять роли.', 'error');
                        return;
                    }
                    if (personId === STATE.telegramUser.id.toString()) {
                        VIEW.showNotification('Вы не можете изменить свою собственную роль.', 'error');
                        return;
                    }
                    if (!STATE.db) {
                        VIEW.showNotification('База данных не инициализирована. Невозможно изменить роль.', 'error');
                        return;
                    }
                    if (STATE.users[personId]) {
                        const usersRef = collection(STATE.db, `artifacts/${STATE.appId}/public/data/${CONFIG.STORAGE_KEYS.USERS_COLLECTION}`);
                        try {
                            await updateDoc(doc(usersRef, personId), { role: newRole });
                            VIEW.showNotification(`Роль ${STATE.users[personId].name} изменена на ${CONFIG.ROLE_NAMES[newRole]}.`, 'success');
                        } catch (e) {
                            console.error("Error changing person role in Firestore:", e);
                            VIEW.showNotification("Ошибка изменения роли сотрудника.", "error");
                        }
                    } else {
                        VIEW.showNotification('Пользователь не найден для изменения роли.', 'error');
                    }
                },
                
                async clearMonth() {
                    if (!(STATE.userRole === 'admin' || STATE.userRole === 'boss')) {
                        VIEW.showNotification('У вас нет прав для очистки месяца.', 'error');
                        return;
                    }
                    const confirmed = await VIEW.showConfirmModal(`Вы уверены, что хотите очистить все данные для текущего месяца в графике "${STATE.activeTab}"?"`);
                    if (!confirmed) return;

                    const keyMap = { duty: 'duties', technician: 'techDuties', general: 'generalSchedule' };
                    STATE[keyMap[STATE.activeTab]][STATE.currentMonth] = {};
                    await this.saveData();
                    VIEW.showNotification(`Данные для текущего месяца в графике "${STATE.activeTab}" очищены.`, 'info');
                },
                
                async cancelChanges() {
                    const confirmed = await VIEW.showConfirmModal('Отменить все несохраненные изменения?');
                    if(confirmed) {
                        this.setupFirestoreListeners(); // Revert to Firestore state
                        VIEW.showNotification('Изменения отменены.', 'info');
                    }
                },

                // Removed saveFirebaseSettings and loadSavedFirebaseSettings as they are no longer needed for manual input

                async reinitializeApp() {
                    VIEW.showLoadingIndicator();
                    // Clear existing Firebase instances and listeners
                    if (STATE.unsubscribeListeners) {
                        STATE.unsubscribeListeners.forEach(unsubscribe => unsubscribe());
                        STATE.unsubscribeListeners = [];
                    }
                    STATE.db = null;
                    STATE.auth = null;
                    STATE.currentUserId = null;
                    STATE.userRole = 'guest';

                    // Re-run the full initialization process
                    await this.init();
                },

                // --- Gemini API Integration ---
                async generateMonthSummary() {
                    VIEW.showLoadingIndicator();
                    try {
                        const monthName = new Date(STATE.year, STATE.currentMonth).toLocaleString('ru-RU', { month: 'long' });
                        const fullMonthName = `${monthName.charAt(0).toUpperCase() + monthName.slice(1)} ${STATE.year}`;

                        let prompt = `Я предоставляю данные о расписании дежурств за ${fullMonthName}. Пожалуйста, сгенерируйте краткую, но информативную сводку, которая включает:\n`;
                        prompt += `1. Общее количество дежурств/смен для каждого сотрудника за месяц.\n`;
                        prompt += `2. Дни, которые кажутся наиболее загруженными (например, с большим количеством назначений).\n`;
                        prompt += `3. Любые интересные закономерности или наблюдения (например, кто дежурил чаще всего, кто имел много выходных).\n\n`;
                        prompt += `Формат данных:\n`;
                        prompt += `График дежурств:\n[День]: [Имя сотрудника] (если есть)\n\n`;
                        prompt += `График техников:\n[День]: [Имя сотрудника] ([Тип смены]), [Имя сотрудника] ([Тип смены]), ...\n\n`;
                        prompt += `Общий график:\n[День]: [Имя сотрудника] ([Тип смены]), [Имя сотрудника] ([Тип смены]), ...\n\n`;
                        prompt += `Данные для ${fullMonthName}:\n`;

                        // Add Duty Schedule data
                        prompt += `График дежурств:\n`;
                        const duties = STATE.duties[STATE.currentMonth] || {};
                        if (Object.keys(duties).length > 0) {
                            Object.keys(duties).sort((a,b) => parseInt(a) - parseInt(b)).forEach(day => {
                                prompt += `${day}: ${duties[day]}\n`;
                            });
                        } else {
                            prompt += `Нет данных.\n`;
                        }

                        // Add Technician Schedule data
                        prompt += `\nГрафик техников:\n`;
                        const techDuties = STATE.techDuties[STATE.currentMonth] || {};
                        if (Object.keys(techDuties).length > 0) {
                            Object.keys(techDuties).sort((a,b) => parseInt(a) - parseInt(b)).forEach(day => {
                                const assignments = techDuties[day].map(a => `${a.person} (${a.shift})`).join(', ');
                                prompt += `${day}: ${assignments}\n`;
                            });
                        } else {
                            prompt += `Нет данных.\n`;
                        }

                        // Add General Schedule data
                        prompt += `\nОбщий график:\n`;
                        const generalSchedule = STATE.generalSchedule[STATE.currentMonth] || {};
                        if (Object.keys(generalSchedule).length > 0) {
                            Object.keys(generalSchedule).sort((a,b) => parseInt(a) - parseInt(b)).forEach(day => {
                                const assignments = generalSchedule[day].map(a => `${a.person} (${a.shift})`).join(', ');
                                prompt += `${day}: ${assignments}\n`;
                            });
                        } else {
                            prompt += `Нет данных.\n`;
                        }

                        prompt += `\nСводка должна быть на русском языке.`;

                        console.log("Sending prompt to LLM:", prompt);

                        let chatHistory = [];
                        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                        const payload = { contents: chatHistory };
                        const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
                        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                        
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const result = await response.json();

                        if (result.candidates && result.candidates.length > 0 &&
                            result.candidates[0].content && result.candidates[0].content.parts &&
                            result.candidates[0].content.parts.length > 0) {
                            const summaryText = result.candidates[0].content.parts[0].text;
                            VIEW.showSummaryModal(summaryText, fullMonthName);
                        } else {
                            VIEW.showNotification('Не удалось сгенерировать сводку. Попробуйте еще раз.', 'error');
                            console.error("LLM response structure unexpected:", result);
                        }
                    } catch (e) {
                        console.error("Error calling Gemini API:", e);
                        VIEW.showNotification('Ошибка при обращении к Gemini API.', 'error');
                    } finally {
                        VIEW.hideLoadingIndicator();
                    }
                }
            };

            /**
             * VIEW: Отвечает за все манипуляции с DOM. Только читает из STATE.
             */
            const VIEW = {
                // DOM elements references, initialized after renderAppShell
                monthSelector: null,
                newOfficerNameInput: null,
                newOfficerTelegramIdInput: null,
                dutyCalendarGrid: null,
                technicianCalendarGrid: null,
                generalCalendarGrid: null,
                statsList: null,
                currentOfficersList: null,
                actionButtonsWrapper: null,
                tabNavigation: null,
                loadingIndicator: null,
                editModalOverlay: null,
                editModalTitle: null,
                editModalBody: null,
                viewModalOverlay: null,
                viewModalTitle: null,
                viewModalBody: null,
                confirmModalOverlay: null,
                confirmModalMessage: null,
                confirmModalConfirmBtn: null,
                confirmModalCancelBtn: null,
                toggleEditModeBtn: null,
                statisticsSection: null,
                managementSection: null,
                summaryModalOverlay: null, // New
                summaryModalTitle: null,   // New
                summaryModalBody: null,    // New
                firebaseSettingsSection: null, // New
                // Removed firebaseConfigInput, firebaseTokenInput, saveFirebaseSettingsBtn
                receivedFirebaseConfig: null,  // New
                receivedToken: null,   // New // Changed selector name to match the HTML
                receivedFirebaseToken: null,   // New
            };

            VIEW.init = function() {
                // This function is now called AFTER renderAppShell has run in SERVICE.init()
                // It's responsible for getting references to the DOM elements.
                this.initAppElements();
                this.renderAll(); // Initial render of data into the shell
            };
            
            VIEW.renderAppShell = function() {
                const container = document.querySelector(CONFIG.DOM_SELECTORS.container);
                // Ensure container exists before setting innerHTML
                if (!container) {
                    console.error("Error: App container not found. Cannot render app shell.");
                    return;
                }
                container.innerHTML = `
                    <header class="header">
                        <div class="user-info" id="userInfo"></div>
                        <h1>Календарь дежурств</h1>
                        <select class="month-selector" id="monthSelector"></select>
                        <button class="btn btn--edit-mode" id="toggleEditModeBtn" data-action="toggleEditMode">Редактировать</button>
                    </header>
                    <main class="main-content">
                        <nav class="tab-navigation" id="tabNavigation">
                            <button class="tab-button active btn" data-tab="duty">График дежурств</button>
                            <button class="tab-button btn" data-tab="technician">График техников</button>
                            <button class="tab-button btn" data-tab="general">Общий график</button>
                        </nav>
                        <div class="section-container">
                            <div id="dutyTab" class="tab-content active"><div class="calendar-grid" id="dutyCalendarGrid" data-calendar-type="duty"></div></div>
                            <div id="technicianTab" class="tab-content"><div class="calendar-grid" id="technicianCalendarGrid" data-calendar-type="technician"></div></div>
                            <div id="generalTab" class="tab-content"><div class="calendar-grid" id="generalCalendarGrid" data-calendar-type="general"></div></div>
                            <div class="action-buttons-wrapper hidden" id="actionButtons">
                                <button class="btn btn--save" data-action="save">Сохранить изменения</button>
                                <button class="btn btn--cancel" data-action="cancel">Отменить изменения</button>
                                <button class="btn btn--clear" data-action="clear">Очистить месяц</button>
                            </div>
                        </div>
                        <button class="btn btn--toggle" data-action="toggleSection" data-target="statisticsSection">Статистика</button>
                        <div class="section-container hidden-section" id="statisticsSection">
                            <h3>Статистика дежурств</h3>
                            <div class="stats-list" id="statsList"></div>
                            <button class="btn btn--blue" style="margin-top: 15px;" data-action="generateMonthSummary">✨ Сгенерировать сводку за месяц</button>
                        </div>
                        <button class="btn btn--toggle" data-action="toggleSection" data-target="managementSection" style="margin-top: 10px;">Управление</button>
                        <div class="section-container hidden-section" id="managementSection">
                            <h3>Управление персоналом</h3>
                            <div class="officer-management-controls">
                                <input type="text" id="newOfficerName" placeholder="Имя нового сотрудника (Фамилия И.О.)">
                                <input type="text" id="newOfficerTelegramId" placeholder="Telegram ID (опционально)">
                                <button class="btn btn--save" data-action="addPerson">Добавить</button>
                            </div>
                            <div class="current-officers-list" id="currentOfficersList"></div>
                        </div>
                        <button class="btn btn--toggle" data-action="toggleSection" data-target="firebaseSettingsSection" style="margin-top: 10px;">Настройки Firebase</button>
                        <div class="section-container" id="firebaseSettingsSection">
                            <h3>Настройки Firebase (для отладки)</h3>
                            <div class="firebase-settings-controls">
                                <p>Полученная __firebase_config: <span id="receivedFirebaseConfig"></span></p>
                                <p>Полученный __initial_auth_token: <span id="receivedFirebaseToken"></span></p>
                            </div>
                        </div>
                    </main>`;
                this.renderUserInfo(); // Render user info immediately after shell is created
            };

            VIEW.initAppElements = function() {
                // Get all static and dynamic elements once the app shell is rendered
                this.monthSelector = document.querySelector(CONFIG.DOM_SELECTORS.monthSelector);
                if (!this.monthSelector) console.error("Element not found:", CONFIG.DOM_SELECTORS.monthSelector);

                this.newOfficerNameInput = document.querySelector(CONFIG.DOM_SELECTORS.newOfficerName);
                if (!this.newOfficerNameInput) console.error("Element not found:", CONFIG.DOM_SELECTORS.newOfficerName);

                this.newOfficerTelegramIdInput = document.querySelector(CONFIG.DOM_SELECTORS.newOfficerTelegramId);
                if (!this.newOfficerTelegramIdInput) console.error("Element not found:", CONFIG.DOM_SELECTORS.newOfficerTelegramId);

                this.dutyCalendarGrid = document.querySelector(CONFIG.DOM_SELECTORS.dutyCalendarGrid);
                if (!this.dutyCalendarGrid) console.error("Element not found:", CONFIG.DOM_SELECTORS.dutyCalendarGrid);

                this.technicianCalendarGrid = document.querySelector(CONFIG.DOM_SELECTORS.technicianCalendarGrid);
                if (!this.technicianCalendarGrid) console.error("Element not found:", CONFIG.DOM_SELECTORS.technicianCalendarGrid);

                this.generalCalendarGrid = document.querySelector(CONFIG.DOM_SELECTORS.generalCalendarGrid);
                if (!this.generalCalendarGrid) console.error("Element not found:", CONFIG.DOM_SELECTORS.generalCalendarGrid);

                this.statsList = document.querySelector(CONFIG.DOM_SELECTORS.statsList);
                if (!this.statsList) console.error("Element not found:", CONFIG.DOM_SELECTORS.statsList);

                this.currentOfficersList = document.querySelector(CONFIG.DOM_SELECTORS.currentOfficersList);
                if (!this.currentOfficersList) console.error("Element not found:", CONFIG.DOM_SELECTORS.currentOfficersList);

                this.actionButtonsWrapper = document.querySelector(CONFIG.DOM_SELECTORS.actionButtons);
                if (!this.actionButtonsWrapper) console.error("Element not found:", CONFIG.DOM_SELECTORS.actionButtons);

                this.tabNavigation = document.querySelector(CONFIG.DOM_SELECTORS.tabNavigation);
                if (!this.tabNavigation) console.error("Element not found:", CONFIG.DOM_SELECTORS.tabNavigation);

                this.loadingIndicator = document.querySelector(CONFIG.DOM_SELECTORS.loadingIndicator);
                if (!this.loadingIndicator) console.error("Element not found:", CONFIG.DOM_SELECTORS.loadingIndicator);

                this.editModalOverlay = document.querySelector(CONFIG.DOM_SELECTORS.editModal.overlay);
                if (!this.editModalOverlay) console.error("Element not found:", CONFIG.DOM_SELECTORS.editModal.overlay);

                this.editModalTitle = document.querySelector(CONFIG.DOM_SELECTORS.editModal.title);
                if (!this.editModalTitle) console.error("Element not found:", CONFIG.DOM_SELECTORS.editModal.title);

                this.editModalBody = document.querySelector(CONFIG.DOM_SELECTORS.editModal.body);
                if (!this.editModalBody) console.error("Element not found:", CONFIG.DOM_SELECTORS.editModal.body);

                this.viewModalOverlay = document.querySelector(CONFIG.DOM_SELECTORS.viewModal.overlay);
                if (!this.viewModalOverlay) console.error("Element not found:", CONFIG.DOM_SELECTORS.viewModal.overlay);

                this.viewModalTitle = document.querySelector(CONFIG.DOM_SELECTORS.viewModal.title);
                if (!this.viewModalTitle) console.error("Element not found:", CONFIG.DOM_SELECTORS.viewModal.title);

                this.viewModalBody = document.querySelector(CONFIG.DOM_SELECTORS.viewModal.body);
                if (!this.viewModalBody) console.error("Element not found:", CONFIG.DOM_SELECTORS.viewModal.body);

                this.confirmModalOverlay = document.querySelector(CONFIG.DOM_SELECTORS.confirmModal.overlay);
                if (!this.confirmModalOverlay) console.error("Element not found:", CONFIG.DOM_SELECTORS.confirmModal.overlay);

                this.confirmModalMessage = document.querySelector(CONFIG.DOM_SELECTORS.confirmModal.message);
                if (!this.confirmModalMessage) console.error("Element not found:", CONFIG.DOM_SELECTORS.confirmModal.message);

                this.confirmModalConfirmBtn = document.querySelector(CONFIG.DOM_SELECTORS.confirmModal.confirmBtn);
                if (!this.confirmModalConfirmBtn) console.error("Element not found:", CONFIG.DOM_SELECTORS.confirmModal.confirmBtn);

                this.confirmModalCancelBtn = document.querySelector(CONFIG.DOM_SELECTORS.confirmModal.cancelBtn);
                if (!this.confirmModalCancelBtn) console.error("Element not found:", CONFIG.DOM_SELECTORS.confirmModal.cancelBtn);

                this.toggleEditModeBtn = document.getElementById('toggleEditModeBtn'); // Get by ID
                if (!this.toggleEditModeBtn) console.error("Element not found: #toggleEditModeBtn");

                this.statisticsSection = document.getElementById('statisticsSection');
                if (!this.statisticsSection) console.error("Element not found: #statisticsSection");

                this.managementSection = document.getElementById('managementSection');
                if (!this.managementSection) console.error("Element not found: #managementSection");

                this.summaryModalOverlay = document.getElementById('summaryModalOverlay'); // New
                if (!this.summaryModalOverlay) console.error("Element not found: #summaryModalOverlay");

                this.summaryModalTitle = document.getElementById('summaryModalTitle');     // New
                if (!this.summaryModalTitle) console.error("Element not found: #summaryModalTitle");

                this.summaryModalBody = document.getElementById('summaryModalBody');       // New
                if (!this.summaryModalBody) console.error("Element not found: #summaryModalBody");

                // New Firebase settings elements
                this.firebaseSettingsSection = document.querySelector(CONFIG.DOM_SELECTORS.firebaseSettings.section);
                if (!this.firebaseSettingsSection) console.error("Element not found:", CONFIG.DOM_SELECTORS.firebaseSettings.section);
                // Removed firebaseConfigInput and firebaseTokenInput
                // this.firebaseConfigInput = document.querySelector(CONFIG.DOM_SELECTORS.firebaseSettings.configInput);
                // if (!this.firebaseConfigInput) console.error("Element not found:", CONFIG.DOM_SELECTORS.firebaseSettings.configInput);
                // this.firebaseTokenInput = document.querySelector(CONFIG.DOM_SELECTORS.firebaseSettings.tokenInput);
                // if (!this.firebaseTokenInput) console.error("Element not found:", CONFIG.DOM_SELECTORS.firebaseSettings.tokenInput);
                // Removed saveFirebaseSettingsBtn
                // this.saveFirebaseSettingsBtn = document.querySelector(CONFIG.DOM_SELECTORS.firebaseSettings.saveBtn);
                // if (!this.saveFirebaseSettingsBtn) console.error("Element not found:", CONFIG.DOM_SELECTORS.firebaseSettings.saveBtn);
                this.receivedFirebaseConfig = document.querySelector(CONFIG.DOM_SELECTORS.firebaseSettings.receivedConfig);
                if (!this.receivedFirebaseConfig) console.error("Element not found:", CONFIG.DOM_SELECTORS.firebaseSettings.receivedConfig);
                this.receivedFirebaseToken = document.querySelector(CONFIG.DOM_SELECTORS.firebaseSettings.receivedToken);
                if (!this.receivedFirebaseToken) console.error("Element not found:", CONFIG.DOM_SELECTORS.firebaseSettings.receivedToken);
            };

            VIEW.showLoadingIndicator = function() {
                // Ensure the indicator element is in the initial HTML or created before this is called
                if (this.loadingIndicator) this.loadingIndicator.style.display = 'flex';
            };

            VIEW.hideLoadingIndicator = function() {
                if (this.loadingIndicator) this.loadingIndicator.style.display = 'none';
            };

            VIEW.renderUserInfo = function() {
                const userInfoContainer = document.getElementById('userInfo'); // This element is part of the shell
                if (userInfoContainer) {
                    const { first_name, username } = STATE.telegramUser;
                    const roleText = CONFIG.ROLE_NAMES[STATE.userRole] || 'Неизвестно';
                    userInfoContainer.innerHTML = `Вы вошли как <span>${first_name}</span> (@${username}) | Роль: <span>${roleText}</span>`;
                }
            };

            VIEW.renderUnauthorized = function(reason) {
                const container = document.querySelector(CONFIG.DOM_SELECTORS.container);
                if (!container) {
                    console.error("Error: App container not found for unauthorized view.");
                    return;
                }
                let messageHtml = '';
                if (reason === 'auth_failed') {
                    messageHtml = `
                        <h1>Ошибка аутентификации</h1>
                        <p>Не удалось войти в систему. Возможно, Firebase Authentication не включен для вашего проекта в консоли Firebase.</p>
                        <p>Пожалуйста, перейдите в <a href="https://console.firebase.google.com/" target="_blank">консоль Firebase</a>, выберите ваш проект "ik2grafik", затем раздел "Authentication" и убедитесь, что хотя бы один метод входа включен (например, "Anonymous" или "Email/Password").</p>
                        <p>После этого попробуйте перезапустить приложение.</p>
                    `;
                } else if (reason === 'guest_role') {
                    messageHtml = `
                        <h1>Доступ ограничен</h1>
                        <p>Ваша заявка на доступ ожидает одобрения администратором.</p>
                        <p>Ваш Telegram ID: <strong>${STATE.telegramUser?.id || 'Неизвестно'}</strong></p>
                        <p>Пожалуйста, сообщите его администратору для получения доступа.</p>
                    `;
                } else {
                    messageHtml = `
                        <h1>Доступ ограничен</h1>
                        <p>Неизвестная причина ограничения доступа.</p>
                    `;
                }

                container.innerHTML = `<div class="unauthorized">${messageHtml}</div>`;
                this.hideLoadingIndicator();
            };

            VIEW.renderAll = function() {
                this.renderMonthSelector();
                this.renderTabsAndButtons();
                this.renderAllCalendars();
                this.renderStatistics();
                this.renderManagementList();
                this.renderFirebaseSettings(); // Render new settings section
            };

            VIEW.renderAllCalendars = function() {
                this.renderCalendar('duty');
                this.renderCalendar('technician');
                this.renderCalendar('general');
            };
            
            VIEW.renderMonthSelector = function() {
                const selector = this.monthSelector; // Use stored reference
                if (!selector) return; // Defensive check
                selector.innerHTML = '';
                for (let i = 0; i < 12; i++) {
                    const monthName = new Date(STATE.year, i).toLocaleString('ru-RU', { month: 'long' });
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `${monthName.charAt(0).toUpperCase() + monthName.slice(1)} ${STATE.year}`;
                    option.selected = (i === STATE.currentMonth);
                    selector.appendChild(option);
                }
            };

            VIEW.renderTabsAndButtons = function() {
                // Use stored references
                if (this.tabNavigation) {
                    this.tabNavigation.querySelectorAll('.tab-button').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.tab === STATE.activeTab);
                    });
                }
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.toggle('active', content.id === `${STATE.activeTab}Tab`);
                });

                // Edit mode button visibility and text
                const editBtn = this.toggleEditModeBtn; // Use stored reference
                if (editBtn) {
                    editBtn.textContent = STATE.isEditMode ? 'Завершить' : 'Редактировать';
                    editBtn.classList.toggle('btn--cancel', STATE.isEditMode);
                    editBtn.classList.toggle('btn--edit-mode', !STATE.isEditMode);
                    editBtn.disabled = !(STATE.userRole === 'admin' || STATE.userRole === 'boss');
                }

                // Action buttons visibility (save/cancel/clear)
                const actionButtonsWrapper = this.actionButtonsWrapper; // Use stored reference
                if (actionButtonsWrapper) {
                    actionButtonsWrapper.classList.toggle('hidden', !STATE.isEditMode);
                    actionButtonsWrapper.querySelectorAll('.btn--save').forEach(btn => {
                        btn.disabled = !STATE.hasUnsavedChanges;
                    });
                    actionButtonsWrapper.querySelectorAll('.btn--cancel, .btn--clear').forEach(btn => {
                        btn.disabled = !(STATE.isEditMode && (STATE.userRole === 'admin' || STATE.userRole === 'boss')); // Only active if in edit mode and has permissions
                    });
                }

                // Management controls (add/delete person)
                const managementSection = this.managementSection; // Use stored reference
                if (managementSection) {
                    // This section is already hidden by default in HTML.
                    // It will be shown if the user is an admin.
                    managementSection.classList.toggle('hidden-section', STATE.userRole !== 'admin'); 
                    const addPersonBtn = managementSection.querySelector('[data-action="addPerson"]');
                    if (addPersonBtn) addPersonBtn.disabled = STATE.userRole !== 'admin';
                    if (this.newOfficerNameInput) this.newOfficerNameInput.disabled = STATE.userRole !== 'admin';
                    if (this.newOfficerTelegramIdInput) this.newOfficerTelegramIdInput.disabled = STATE.userRole !== 'admin';
                }
            };

            VIEW.renderCalendar = function(calendarType) {
                const grid = this[`${calendarType}CalendarGrid`]; // Use stored reference
                if (!grid) return;

                const dataMap = { duty: STATE.duties, technician: STATE.techDuties, general: STATE.generalSchedule };
                const monthData = dataMap[calendarType][STATE.currentMonth] || {};
                
                const fragment = document.createDocumentFragment();
                ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'].forEach(day => {
                    const header = document.createElement('div');
                    header.className = 'day-header';
                    header.textContent = day;
                    fragment.appendChild(header);
                });

                const firstDayOfMonth = new Date(STATE.year, STATE.currentMonth, 1);
                const daysInMonth = new Date(STATE.year, STATE.currentMonth + 1, 0).getDate();
                const firstDayOfWeek = (firstDayOfMonth.getDay() + 6) % 7; // Adjust to make Monday first day (0=Mon, 6=Sun)

                for (let i = 0; i < firstDayOfWeek; i++) {
                    fragment.appendChild(document.createElement('div')).className = 'day-cell empty';
                }

                const today = new Date();
                for (let day = 1; day <= daysInMonth; day++) {
                    const cell = document.createElement('div');
                    cell.className = 'day-cell';
                    cell.dataset.day = day;
                    
                    const date = new Date(STATE.year, STATE.currentMonth, day);
                    const dayOfWeek = (date.getDay() + 6) % 7; // Adjust for weekend check
                    if (dayOfWeek >= 5) cell.classList.add('weekend'); // Saturday and Sunday
                    if (date.toDateString() === today.toDateString()) cell.classList.add('current-day');
                    
                    cell.innerHTML = `<div class="day-number">${day}</div><div class="day-entries-container"></div>`;
                    
                    const dayAssignments = monthData[day] || [];
                    // Ensure dayAssignments is always an array for consistent processing
                    const assignmentsArray = Array.isArray(dayAssignments) ? dayAssignments : (typeof dayAssignments === 'string' ? [{ person: dayAssignments, shift: '' }] : []);
                    
                    const entriesContainer = cell.querySelector('.day-entries-container');
                    assignmentsArray.forEach(a => entriesContainer.appendChild(this.createDayEntry(a.person, a.shift)));
                    
                    fragment.appendChild(cell);
                }
                
                grid.innerHTML = '';
                grid.appendChild(fragment);
            };
            
            VIEW.createDayEntry = function(person, shift) {
                const entry = document.createElement('div');
                entry.className = 'day-entry';
                entry.title = shift ? `${person} (${shift})` : person;
                
                const personColor = this.getColorFor(person);
                entry.style.backgroundColor = personColor;
                entry.style.color = this.isLightColor(personColor) ? '#333' : '#fff';
                
                // Display only the last name or full name with initials
                const displayName = person.match(/^[А-ЯЁ]\.[А-ЯЁ]\.$/) ? person : person.split(' ')[0];
                entry.innerHTML = `<span>${displayName}</span>` + (shift ? `<span class="shift-type">(${shift})</span>` : '');
                return entry;
            };

            VIEW.renderStatistics = function() {
                const stats = {};
                // Only count officers who are in the current officers list (derived from users)
                STATE.officers.filter(o => o !== CONFIG.NO_DUTY_LABEL).forEach(officer => {
                    stats[officer] = 0;
                });
                
                Object.values(STATE.duties[STATE.currentMonth] || {}).forEach(officer => {
                    if (officer && officer !== CONFIG.NO_DUTY_LABEL) {
                        stats[officer] = (stats[officer] || 0) + 1;
                    }
                });
                
                const sortedOfficers = Object.keys(stats).sort((a, b) => stats[b] - stats[a] || a.localeCompare(b));
                
                const statsList = this.statsList; // Use stored reference
                if (!statsList) return; // Defensive check
                statsList.innerHTML = '';
                sortedOfficers.forEach(officer => {
                    const item = document.createElement('div');
                    item.className = 'stats-item';
                    const color = this.getColorFor(officer);
                    item.innerHTML = `<div class="stats-name" style="background-color:${color}; color:${this.isLightColor(color) ? '#333' : '#fff'}">${officer}</div>
                                      <div class="stats-count">${stats[officer]}</div>`;
                    statsList.appendChild(item);
                });
            };
            
            VIEW.renderManagementList = function() {
                const list = this.currentOfficersList; // Use stored reference
                if (!list) return; // Defensive check
                list.innerHTML = '';

                // Get all users from STATE.users, sorted by name
                const allUsers = Object.entries(STATE.users).sort(([, a], [, b]) => a.name.localeCompare(b.name));

                allUsers.forEach(([id, userData]) => {
                    const item = document.createElement('div');
                    item.className = 'current-officer-item';
                    
                    const telegramIdDisplay = id.startsWith('_ph_') ? '' : ` (ID: ${id})`; // Don't show placeholder IDs
                    item.innerHTML = `<span class="person-name">${userData.name}</span>
                                      <span class="telegram-id">${telegramIdDisplay}</span>`;

                    // Role selector
                    const roleSelect = document.createElement('select');
                    roleSelect.className = 'role-selector';
                    roleSelect.dataset.personId = id; // Store the ID for lookup
                    
                    // Admin can assign boss, worker, guest roles
                    const rolesToAssign = ['boss', 'worker', 'guest'];
                    rolesToAssign.forEach(role => {
                        const option = document.createElement('option');
                        option.value = role;
                        option.textContent = CONFIG.ROLE_NAMES[role];
                        if (userData.role === role) {
                            option.selected = true;
                        }
                        roleSelect.appendChild(option);
                    });

                    // Disable selector if not admin or if it's the current admin's entry
                    if (STATE.userRole !== 'admin' || id === STATE.telegramUser.id.toString()) {
                        roleSelect.disabled = true;
                    }
                    roleSelect.addEventListener('change', (e) => {
                        SERVICE.changePersonRole(e.target.dataset.personId, e.target.value);
                    });
                    item.appendChild(roleSelect);

                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-officer-btn';
                    deleteBtn.innerHTML = '&times;'; 
                    deleteBtn.title = `Удалить ${userData.name}`;
                    deleteBtn.dataset.action = 'deletePerson'; // New action name
                    deleteBtn.dataset.personIdToDelete = id; // Pass the ID to delete

                    if (STATE.userRole !== 'admin' || id === STATE.telegramUser.id.toString()) { // Admin cannot delete self
                        deleteBtn.disabled = true;
                    }

                    item.appendChild(deleteBtn);
                    list.appendChild(item);
                });
            };

            // --- Модальные окна ---
            VIEW.showDutyModal = function() {
                const modal = this.editModalBody; // Use stored reference
                if (!modal) return; // Defensive check
                this.editModalTitle.textContent = 'Выберите дежурного'; // Use stored reference
                
                const currentAssignment = STATE.duties[STATE.currentMonth][STATE.currentSelectedDay];
                const optionsHTML = [...STATE.officers, CONFIG.NO_DUTY_LABEL].map(name => {
                    const isSelected = (name === currentAssignment || (!currentAssignment && name === CONFIG.NO_DUTY_LABEL));
                    return `<button class="officer-option btn ${isSelected ? 'selected' : ''}" data-action="selectDuty" data-name="${name}">${name}</button>`;
                }).join('');
                
                modal.innerHTML = `<div class="officer-list">${optionsHTML}</div>`;
                this.openModal('edit');
            };

            VIEW.showAssignmentModal = function(calendarType) {
                const modal = this.editModalBody; // Use stored reference
                if (!modal) return; // Defensive check
                this.editModalTitle.textContent = `Назначить смену на ${STATE.currentSelectedDay}-е число`; // Use stored reference
                modal.dataset.calendarType = calendarType;

                const people = calendarType === 'technician' ? STATE.technicians : STATE.officers.concat(STATE.technicians).filter((v, i, a) => a.indexOf(v) === i).sort();
                
                const peopleOptionsHTML = people.map(p => `<option value="${p}">${p}</option>`).join('');
                // Filter out "ДС" for technicians calendar, but allow for general
                const shiftsForSelect = (calendarType === 'technician') ? CONFIG.SHIFT_TYPES.filter(s => s !== "ДС") : CONFIG.SHIFT_TYPES;
                const shiftOptionsHTML = shiftsForSelect.map((s, i) => `<option value="${s}" ${i === 0 ? 'selected' : ''}>${s}</option>`).join('');

                modal.innerHTML = `
                    <div class="assignment-controls">
                        <select id="personSelect">${peopleOptionsHTML}</select>
                        <select id="shiftSelect">${shiftOptionsHTML}</select>
                        <button class="btn btn--save" data-action="addAssignment">Добавить назначение</button>
                    </div>
                    <div class="assignments-list-container">
                        <h5>Текущие назначения:</h5>
                        <div id="assignmentsList"></div>
                    </div>`;
                
                this.renderAssignmentModalList(calendarType);
                this.openModal('edit');
            };

            VIEW.showEnlargedDayView = function(day) {
                const { year, currentMonth } = STATE;
                const fullDate = new Date(year, currentMonth, day).toLocaleString('ru-RU', { day: 'numeric', month: 'long', year: 'numeric' });
                this.viewModalTitle.textContent = fullDate; // Use stored reference
                const body = this.viewModalBody; // Use stored reference
                if (!body) return; // Defensive check
                body.innerHTML = '';

                // Collect all assignments for this day from all schedules
                const allAssignments = [];
                if (STATE.duties[currentMonth] && STATE.duties[currentMonth][day]) {
                    allAssignments.push({ person: STATE.duties[currentMonth][day], shift: 'ДС' });
                }
                if (STATE.techDuties[currentMonth] && Array.isArray(STATE.techDuties[currentMonth][day])) {
                    allAssignments.push(...STATE.techDuties[currentMonth][day]);
                }
                if (STATE.generalSchedule[currentMonth] && Array.isArray(STATE.generalSchedule[currentMonth][day])) {
                    allAssignments.push(...STATE.generalSchedule[currentMonth][day]);
                }
                
                // Filter out duplicates (person + shift)
                const uniqueAssignments = Array.from(new Map(allAssignments.map(a => [`${a.person}-${a.shift}`, a])).values());
                
                if (uniqueAssignments.length === 0) {
                    body.innerHTML = '<p>На этот день нет назначений.</p>';
                } else {
                    uniqueAssignments.sort((a,b) => a.person.localeCompare(b.person));
                    uniqueAssignments.forEach(a => {
                        const p = document.createElement('p');
                        const color = this.getColorFor(a.person);
                        p.style.backgroundColor = color;
                        p.style.color = this.isLightColor(color) ? '#333' : '#fff';
                        p.textContent = `${a.person} (${a.shift})`;
                        body.appendChild(p);
                    });
                }
                this.openModal('view');
            };
            
            VIEW.renderAssignmentModalList = function(calendarType) {
                const list = document.getElementById('assignmentsList'); // This is a child of editModalBody, so it's created dynamically
                if (!list) return;
                
                const keyMap = { technician: 'techDuties', general: 'generalSchedule' };
                const assignments = STATE[keyMap[calendarType]][STATE.currentMonth][STATE.currentSelectedDay] || [];
                
                if (assignments.length === 0) {
                    list.innerHTML = 'Нет назначений.';
                    return;
                }
                list.innerHTML = assignments.map((a, i) => `
                    <div class="assignment-item">
                        <span>${a.person} (${a.shift})</span>
                        <button class="delete-assignment-btn" data-action="deleteAssignment" data-index="${i}">&times;</button>
                    </div>`).join('');
            };

            VIEW.openModal = function(type) {
                const overlay = this[`${type}ModalOverlay`]; // Use stored reference
                if (overlay) overlay.classList.add('show');
                document.querySelector(`.day-cell[data-day='${STATE.currentSelectedDay}']`)?.classList.add('selected-for-modal');
            };

            VIEW.closeModal = function() {
                if (this.editModalOverlay) this.editModalOverlay.classList.remove('show');
                if (this.viewModalOverlay) this.viewModalOverlay.classList.remove('show');
                const prevSelected = document.querySelector('.day-cell.selected-for-modal');
                if (prevSelected) prevSelected.classList.remove('selected-for-modal');
                STATE.currentSelectedDay = null;
            };
            
            VIEW.showConfirmModal = function(message) {
                return new Promise(resolve => {
                    STATE.confirmModalResolve = resolve;
                    if (this.confirmModalMessage) this.confirmModalMessage.textContent = message;
                    if (this.confirmModalOverlay) this.confirmModalOverlay.classList.add('show');
                });
            };

            VIEW.closeConfirmModal = function(result) {
                if (this.confirmModalOverlay) this.confirmModalOverlay.classList.remove('show');
                if (STATE.confirmModalResolve) {
                    STATE.confirmModalResolve(result);
                    STATE.confirmModalResolve = null;
                }
            };

            // New summary modal functions
            VIEW.showSummaryModal = function(summaryText, monthYear) {
                if (this.summaryModalTitle) this.summaryModalTitle.textContent = `Сводка за ${monthYear}`;
                if (this.summaryModalBody) this.summaryModalBody.innerHTML = `<pre style="white-space: pre-wrap; word-wrap: break-word;">${summaryText}</pre>`;
                if (this.summaryModalOverlay) this.summaryModalOverlay.classList.add('show');
            };

            VIEW.closeSummaryModal = function() {
                if (this.summaryModalOverlay) this.summaryModalOverlay.classList.remove('show');
            };

            // New Firebase settings rendering
            VIEW.renderFirebaseSettings = function() {
                if (!this.receivedFirebaseConfig || !this.receivedFirebaseToken) {
                    console.error("Firebase settings elements not found for rendering.");
                    return;
                }

                // Display received global variables (for debugging)
                this.receivedFirebaseConfig.textContent = typeof __firebase_config !== 'undefined' && __firebase_config ? __firebase_config : 'Не получено';
                this.receivedFirebaseToken.textContent = typeof __initial_auth_token !== 'undefined' && __initial_auth_token ? __initial_auth_token.substring(0, 50) + '...' : 'Не получено'; // Truncate for display
            };

            // --- Утилиты ---
            VIEW.showNotification = function(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);
                
                setTimeout(() => notification.classList.add('show'), 10);
                setTimeout(() => {
                    notification.classList.remove('show');
                    notification.addEventListener('transitionend', () => notification.remove());
                }, 3000);
            };
            
            VIEW.getColorFor = function(str) {
                if(!str) return '#ccc';
                if (STATE.colors[str]) return STATE.colors[str];
                let hash = 0;
                for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
                let color = '#';
                for (let i = 0; i < 3; i++) {
                    const value = (hash >> (i * 8)) & 0xFF;
                    color += ('00' + value.toString(16)).substr(-2);
                }
                return STATE.colors[str] = color;
            };

            VIEW.isLightColor = function(hex) {
                const r = parseInt(hex.substring(1, 3), 16);
                const g = parseInt(hex.substring(3, 5), 16);
                const b = parseInt(hex.substring(5, 7), 16);
                return (r * 299 + g * 587 + b * 114) / 1000 > 180;
            };

            /**
             * CONTROLLER: Связывает действия пользователя с логикой приложения.
             */
            const CONTROLLER = {
                init() {
                    document.body.addEventListener('click', this.globalClickListener.bind(this));
                    // Use stored reference for monthSelector
                    if (VIEW.monthSelector) {
                        VIEW.monthSelector.addEventListener('change', e => {
                            SERVICE.changeMonth(e.target.value);
                        });
                    }
                },

                globalClickListener(e) {
                    const target = e.target;
                    
                    const dayCell = target.closest('.day-cell:not(.empty)');
                    if (dayCell) {
                        const grid = dayCell.closest('.calendar-grid');
                        SERVICE.handleDayClick(parseInt(dayCell.dataset.day, 10), grid.dataset.calendarType);
                        return;
                    }

                    const tabButton = target.closest('.tab-button[data-tab]');
                    if (tabButton) {
                        SERVICE.switchTab(tabButton.dataset.tab);
                        return;
                    }

                    const actionTarget = target.closest('[data-action]');
                    if (actionTarget) {
                        const { action, name, index, personIdToDelete } = actionTarget.dataset; // Added personIdToDelete
                        
                        switch (action) {
                            case 'toggleEditMode': SERVICE.toggleEditMode(); break;
                            case 'save': SERVICE.saveData(); break;
                            case 'clear': SERVICE.clearMonth(); break;
                            case 'cancel': SERVICE.cancelChanges(); break;
                            case 'toggleSection': document.getElementById(actionTarget.dataset.target)?.classList.toggle('hidden-section'); break;
                            case 'addPerson': SERVICE.addPerson(VIEW.newOfficerNameInput.value, VIEW.newOfficerTelegramIdInput.value); break; // Use stored references
                            case 'deletePerson': SERVICE.deletePerson(personIdToDelete); break; // Changed to deletePerson
                            case 'closeModal': VIEW.closeModal(); break;
                            case 'closeConfirmModal': VIEW.closeConfirmModal(false); break;
                            case 'closeSummaryModal': VIEW.closeSummaryModal(); break; // New
                            case 'selectDuty': SERVICE.assignDuty(name); break;
                            case 'addAssignment': {
                                const modalBody = target.closest('.modal-body');
                                const person = modalBody.querySelector('#personSelect').value;
                                const shift = modalBody.querySelector('#shiftSelect').value;
                                SERVICE.addAssignment(person, shift, modalBody.dataset.calendarType);
                                break;
                            }
                            case 'deleteAssignment': {
                                 const modalBody = target.closest('.modal-body');
                                 SERVICE.deleteAssignment(parseInt(index, 10), modalBody.dataset.calendarType);
                                 break;
                            }
                            case 'generateMonthSummary': SERVICE.generateMonthSummary(); break; // New
                            // Removed case 'saveFirebaseSettings': SERVICE.saveFirebaseSettings(); break;
                        }
                    }
                    
                    if(target.matches(CONFIG.DOM_SELECTORS.confirmModal.confirmBtn)) VIEW.closeConfirmModal(true);
                    if(target.matches(CONFIG.DOM_SELECTORS.confirmModal.cancelBtn)) VIEW.closeConfirmModal(false);
                }
            };

            // Initial Telegram Web App setup and Firebase authentication
            document.addEventListener('DOMContentLoaded', () => {
                SERVICE.init();
            });

        })(); // Конец IIFE
    </script>
    <style>
        /* Общие стили */
        :root {
            --bg-main: #1a1a2e;
            --bg-container: #0f3460;
            --bg-element: #2d3748;
            --bg-element-hover: #4a5568;
            --bg-accent: #533483;
            --bg-weekend: #3d2a45;
            --text-main: #e0e6ed;
            --text-light: #ffffff;
            --border-main: #4a5568;
            --border-accent: #00bfff;
            --btn-green: #059669;
            --btn-green-hover: #047857;
            --btn-red: #dc2626;
            --btn-red-hover: #b91c1c;
            --btn-blue: #2563eb;
            --btn-blue-hover: #1d4ed8;
            --shadow-main: rgba(0,0,0,0.3);
            --shadow-accent: rgba(0, 191, 255, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-main);
            min-height: 100vh;
            padding: 10px;
            color: var(--text-main);
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            background: var(--bg-container);
            border-radius: 20px;
            box-shadow: 0 20px 40px var(--shadow-main);
            overflow: hidden;
        }
        .unauthorized {
            text-align: center;
            padding: 50px;
        }

        /* Заголовок */
        .header {
            background: linear-gradient(135deg, var(--bg-accent) 0%, var(--bg-container) 100%);
            color: var(--text-light);
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            text-align: center;
        }
        .user-info {
            font-size: 0.9em;
            opacity: 0.9;
        }
        .user-info span {
            font-weight: bold;
        }

        .header h1 {
            font-size: 2em;
            font-weight: 300;
        }

        .month-selector {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 10px 15px;
            color: var(--text-light);
            font-size: 14px;
            cursor: pointer;
            width: 100%;
            max-width: 250px;
        }

        .month-selector option {
            background: var(--bg-container);
            color: var(--text-light);
        }

        /* Кнопки */
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            min-height: 44px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            color: var(--text-light);
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .btn--save { background: var(--btn-green); }
        .btn--save:hover:not(:disabled) { background: var(--btn-green-hover); }
        .btn--clear { background: var(--btn-red); }
        .btn--clear:hover:not(:disabled) { background: var(--btn-red-hover); }
        .btn--cancel { background: var(--bg-element-hover); }
        .btn--cancel:hover:not(:disabled) { background: var(--bg-element); }
        .btn--edit-mode, .btn--blue { background: var(--btn-blue); }
        .btn--edit-mode:hover:not(:disabled), .btn--blue:hover:not(:disabled) { background: var(--btn-blue-hover); }
        .btn--toggle {
            background: var(--bg-element);
            border: 1px solid var(--border-main);
            box-shadow: none;
            padding: 8px 15px;
        }
        .btn--toggle:hover:not(:disabled) {
            background: var(--bg-element-hover);
            transform: none;
        }

        /* Основное содержимое */
        .main-content {
            padding: 20px;
        }

        .section-container {
            background: var(--bg-main);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid var(--bg-element);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .section-container h3 {
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        /* Навигация */
        .tab-navigation {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
            flex-wrap: wrap;
        }
        .tab-button {
            background: var(--bg-element-hover);
            padding: 10px 20px;
            border-radius: 10px;
            min-width: 150px;
            text-align: center;
        }
        .tab-button.active {
            background: linear-gradient(135deg, var(--bg-accent) 0%, var(--bg-container) 100%);
            border: 2px solid var(--border-accent);
            box-shadow: 0 0 15px var(--shadow-accent);
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* Сетка календаря */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            background: var(--bg-element);
            border-radius: 10px;
            overflow: hidden;
        }
        .day-header {
            background: var(--bg-element-hover);
            padding: 12px 8px;
            text-align: center;
            font-weight: 600;
            font-size: 12px;
        }
        .day-cell {
            background: var(--bg-element);
            min-height: 100px;
            padding: 8px 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            gap: 4px;
            border: 1px solid var(--border-main);
            border-radius: 8px;
        }
        .day-cell:hover:not(.empty) {
            background: var(--bg-element-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px var(--shadow-main);
        }
        .day-cell.weekend { background: var(--bg-weekend); }
        .day-cell.weekend:hover:not(:disabled) { background: #553c5d; }
        .day-cell.empty {
            background: var(--bg-main);
            cursor: default;
            box-shadow: none;
            transform: none;
        }
        .day-cell.current-day {
            border: 2px solid var(--border-accent);
            box-shadow: 0 0 15px var(--shadow-accent);
        }
        .day-cell.selected-for-modal {
            border: 3px solid var(--border-accent);
            box-shadow: 0 0 25px rgba(0, 191, 255, 0.9);
            transform: scale(1.03);
        }
        .day-number {
            font-weight: 600;
            font-size: 15px;
        }
        .day-entries-container {
            display: flex;
            flex-direction: column;
            gap: 3px;
            flex-grow: 1;
            overflow: hidden;
        }
        .day-entry {
            font-size: 10px;
            padding: 3px 4px;
            line-height: 1.2;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-radius: 4px;
            text-align: center;
            font-weight: 500;
        }
        .day-entry .shift-type {
            font-size: 8px;
            margin-left: 4px;
            opacity: 0.8;
        }

        /* Кнопки действий */
        .action-buttons-wrapper {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .action-buttons-wrapper.hidden {
            display: none;
        }

        /* Секции статистики и управления */
        .hidden-section { display: none; }
        .stats-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
        }
        .stats-item {
            background: var(--bg-element);
            padding: 12px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .stats-name {
            font-weight: 500;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .stats-count {
            font-size: 16px;
            font-weight: 600;
            background: var(--bg-element-hover);
            padding: 4px 10px;
            border-radius: 15px;
        }
        .officer-management-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .officer-management-controls input[type="text"] {
            flex-grow: 1;
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid var(--border-main);
            background: var(--bg-element);
            color: var(--text-main);
            min-width: 150px;
        }
        .current-officers-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px;
        }
        .current-officer-item {
            background: var(--bg-element);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid var(--border-main);
            display: flex;
            flex-wrap: wrap; /* Allow wrapping for smaller screens */
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            gap: 5px; /* Gap between elements in the item */
        }
        .current-officer-item .person-name {
            font-weight: 500;
            flex-basis: 100%; /* Take full width on small screens */
            margin-bottom: 5px;
        }
        .current-officer-item .telegram-id {
            font-size: 0.8em;
            opacity: 0.7;
            flex-basis: 100%; /* Take full width on small screens */
            margin-bottom: 5px;
        }
        .current-officer-item .role-selector {
            padding: 5px 8px;
            border-radius: 6px;
            border: 1px solid var(--border-main);
            background: var(--bg-main);
            color: var(--text-main);
            font-size: 0.9em;
            flex-grow: 1; /* Allow to grow */
            min-width: 100px; /* Minimum width for selector */
        }
        .current-officer-item .delete-officer-btn {
            background: none;
            border: none;
            color: var(--btn-red);
            font-size: 20px;
            cursor: pointer;
            transition: color 0.2s ease;
            padding: 5px;
            border-radius: 50%;
            width: 36px; /* Smaller touch target for delete */
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .current-officer-item .delete-officer-btn:hover:not(:disabled) {
            color: var(--btn-red-hover);
            background: rgba(220, 38, 38, 0.2);
        }

        /* Модальные окна */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal {
            background: var(--bg-container);
            border-radius: 15px;
            width: 90%;
            max-width: 450px;
            border: 1px solid var(--bg-element);
            box-shadow: 0 10px 20px var(--shadow-main);
            transform: translateY(-50px);
            transition: all 0.3s ease;
        }
        .modal-overlay.show .modal {
            transform: translateY(0);
        }
        .modal-header {
            background: linear-gradient(135deg, var(--bg-accent) 0%, var(--bg-container) 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h4 { font-size: 1.2em; font-weight: 500; }
        .modal-close {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 24px;
            cursor: pointer;
            border-radius: 50%;
            width: 44px; height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-close:hover { background: rgba(255,255,255,0.2); }
        .modal-body { padding: 20px; max-height: 60vh; overflow-y: auto; }
        
        /* Содержимое модальных окон */
        .officer-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .officer-option {
            padding: 15px;
            border: 2px solid var(--border-main);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--bg-element);
            text-align: center;
        }
        .officer-option:hover {
            border-color: var(--bg-accent);
            background: var(--bg-element-hover);
        }
        .officer-option.selected {
            border-color: var(--bg-accent);
            background: var(--bg-accent);
            color: var(--text-light);
        }
        .assignment-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid var(--border-main);
            border-radius: 8px;
            padding: 10px;
            background: var(--bg-element);
            margin-bottom: 15px;
        }
        .assignment-controls select, .assignment-controls input {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--bg-accent);
            background: var(--bg-main);
            color: var(--text-main);
        }
        .assignments-list-container h5 { margin-bottom: 10px; }
        .assignment-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: var(--bg-main);
            border-radius: 6px;
            margin-bottom: 5px;
        }
        .assignment-item .delete-assignment-btn {
            background: none; border: none; color: var(--btn-red); font-size: 18px; cursor: pointer;
        }
        .confirm-modal .modal-body { text-align: center; font-size: 1.1em; }
        .confirm-modal .modal-footer { display: flex; justify-content: center; gap: 15px; padding: 20px; }

        /* Уведомления */
        .notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(150%);
            padding: 15px 25px;
            border-radius: 8px;
            color: var(--text-light);
            font-weight: 500;
            z-index: 2000;
            transition: transform 0.4s ease-in-out;
            box-shadow: 0 5px 15px var(--shadow-main);
        }
        .notification.show { transform: translateX(-50%) translateY(0); }
        .notification.success { background: var(--btn-green); }
        .notification.error { background: var(--btn-red); }
        .notification.info { background: var(--btn-blue); }
        
        /* Увеличенный просмотр дня */
        .enlarged-day-content {
            padding: 30px;
            text-align: center;
        }
        .enlarged-day-content h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: var(--border-accent);
        }
        .enlarged-day-content p {
            font-size: 1.2em;
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
        }

        /* Адаптивность */
        @media (max-width: 768px) {
            body { padding: 5px; }
            .header h1 { font-size: 1.5em; }
            .main-content, .section-container { padding: 15px; }
            .day-cell { min-height: 80px; padding: 6px 4px; }
            .day-number { font-size: 14px; }
            .day-entry { font-size: 9px; }
            .stats-list, .current-officers-list { grid-template-columns: 1fr; }
            .officer-list { grid-template-columns: 1fr; }
            .tab-button { flex-grow: 1; }
            .current-officer-item .person-name,
            .current-officer-item .telegram-id,
            .current-officer-item .role-selector {
                flex-basis: auto; /* Allow items to shrink/grow */
                width: 100%; /* Take full width */
            }
            .current-officer-item .delete-officer-btn {
                margin-left: auto; /* Push to the right */
            }
        }

        /* Дополнительные стили для очень маленьких экранов */
        @media (max-width: 480px) {
            .day-cell {
                min-height: 70px; /* Further reduced height */
                padding: 4px 2px; /* Reduced padding */
            }
            .day-number {
                font-size: 12px; /* Smaller font for day number */
            }
            .day-entry {
                font-size: 7px; /* Smaller font for entries */
            }
            .calendar-grid {
                gap: 1px; /* Reduced gap */
            }
        }

        @media (max-width: 375px) {
            .day-cell {
                min-height: 60px; /* Even smaller height for tiny screens */
                padding: 3px 1px; /* Minimal padding */
            }
            .day-number {
                font-size: 11px; /* Even smaller font for day number */
            }
            .day-entry {
                font-size: 6px; /* Even smaller font for entries */
            }
            .calendar-grid {
                gap: 0px; /* No gap */
            }
        }

        /* Firebase Settings Section Specific Styles */
        .firebase-settings-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .firebase-settings-controls label {
            font-weight: 500;
            margin-top: 5px;
        }
        .firebase-settings-controls textarea,
        .firebase-settings-controls input[type="text"] {
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid var(--border-main);
            background: var(--bg-element);
            color: var(--text-main);
            font-family: 'monospace';
            font-size: 0.9em;
        }
        .firebase-settings-controls .btn--save {
            margin-top: 10px;
        }
        .debug-info {
            background: var(--bg-element-hover);
            border: 1px solid var(--border-main);
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
            font-size: 0.85em;
            word-break: break-all;
        }
        .debug-info p {
            margin-bottom: 5px;
        }
        .debug-info span {
            font-weight: bold;
            color: var(--border-accent);
        }
    </style>
</head>
<body>
    <div id="loadingIndicator" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; color: white; font-size: 1.5em; z-index: 9999;">Загрузка...</div>
    <div class="container" id="appContainer">
        <!-- App content will be rendered here by JavaScript -->
    </div>

    <!-- MODALS (kept outside the main container for positioning) -->
    <!-- Universal Modal for Editing -->
    <div class="modal-overlay" id="editModalOverlay">
        <div class="modal" id="editModal">
            <div class="modal-header">
                <h4 id="editModalTitle"></h4>
                <button class="modal-close" data-action="closeModal">&times;</button>
            </div>
            <div class="modal-body" id="editModalBody"></div>
        </div>
    </div>
    
    <!-- Enlarged Day View Modal -->
    <div class="modal-overlay" id="viewModalOverlay" data-action="closeModal">
        <div class="modal">
            <div class="modal-header">
                <h4 id="viewModalTitle">Просмотр дня</h4>
                <button class="modal-close" data-action="closeModal">&times;</button>
            </div>
            <div class="modal-body enlarged-day-content" id="viewModalBody"></div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal-overlay confirm-modal" id="confirmModalOverlay">
        <div class="modal">
            <div class="modal-header">
                <h4>Подтверждение</h4>
                <button class="modal-close" data-action="closeConfirmModal">&times;</button>
            </div>
            <div class="modal-body" id="confirmModalMessage"></div>
            <div class="modal-footer">
                <button class="btn btn--save" id="confirmModalConfirmBtn">Да</button>
                <button class="btn btn--cancel" id="confirmModalCancelBtn">Отмена</button>
            </div>
        </div>
    </div>

    <!-- New Summary Modal -->
    <div class="modal-overlay" id="summaryModalOverlay">
        <div class="modal">
            <div class="modal-header">
                <h4 id="summaryModalTitle">Сводка за месяц</h4>
                <button class="modal-close" data-action="closeSummaryModal">&times;</button>
            </div>
            <div class="modal-body" id="summaryModalBody" style="max-height: 70vh;"></div>
        </div>
    </div>
</body>
</html>
